---
title: 了解注解
tags:
- 注解
- 学习笔记
categories:
- Java 基础
---

# 什么是注解
**注解**（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻方便地使用这些数据。
注解可以提供用来完整地描述程序所需的信息，而这些信息是无法用Java来表达的。

## 注解的作用及好处
-  使我们能够以将由编译器来测试和验证的格式，存储有关程序的额外信息。
-  注解可以用来生成描述符文件，甚至是新的类定义，并且有助于减轻编写“样板”代码的负担。
-  通过使用注解，我们可以将这些元数据保存在 Java 源代码中，并利用 annotation API 为自己的注解构造处理工具。
- 更加干净易读的代码以及编译期类型检查。

# 注解的基本语法
注解的语法比较简单，除了 @ 符号的使用之外，他基本与 Java 固有的语法一致。
Java SE5 内置了三种，定义在 java.lang 中的注解：@Override 、@Deprecated、@SuppressWarnings。
## 基本示例
在下面的例子中，使用 @Test 对 testExecute() 方法进行注解。该注解本身并不做任何事情，但是编译器要确保在其构造路径上必须有 @Test 注解的定义。

定义注解：
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {}
```

以上代码就是 @Test 注解的定义，与接口的定义非常类似，事实上，注解与接口一样，也会编译成 class文件。
除了 @ 符号以外，@ Test 的定义很像一个空的接口。定义注解时，会需要一些元注解（meta-annotation）,如 @Target 和 @Retention。@Target 用来定义你的注解将应用于什么地方（例如一个方法或者是一个域）。@Rectetion 用来定义该注解在哪一个级别可用，在源代码中（SOURCE）、类文件(CLASS)中或者运行时(RUNTIME)。
在注解中，一般都会包含一些元素以表达某些值，当分析处理注解时，程序或工具可以利用这些值。注解元素看起来就像接口的方法，唯一的区别就是你可以为其指定默认值。
没有元素的注解称为标记注解(marker annotation)，例如上例中的 @Test。


给方法加注解：

```java
public class Testable {
  public void execute(){
      System.out.println("Executing..");
  }
  @Test void testExecute(){execute();}
}
```

被注解的方法与其他方法没有区别。这个例子中，注解 @Test可以与任何修饰符共同作用于方法，从语法角度看，注解的使用方式几乎和修饰符的使用一模一样。

# 元注解
Java 目前内置了三种标准注解（@Override、@Deprecated、@SuppressWarnings），以及四种元注解，元注解专职负责注解其他的注解：

--------
  * @Target表示该注解可以作用于什么地方。可能的 ElementType 参数包括：
       - CONSTRUCTOR:构造器的声明
       - FIELD:域（即成员变量）声明（包括enum实例）
       - LOCAL_VARIABLE:局部变量声明
       - METHOD:方法声明
       - PACKAGE:包声明
       - PARAMTETER:参数声明
       - TYPE:类、接口（包括注解类型）或enum声明
--------
  * @Retention表示需要什么级别保存该注解信息。。可选的 RetentionPolicy 参数包括：
       - SOURCE:注解将被编译器丢弃
       - CLASS:注解在 class 文件中可用，但会被 VM 丢弃
       - RUNTIME:VM 将在运行期也保留注解，因此可通过反射机制读取注解信息
--------
* @Documented ：将此注解包含在 Javadoc中

--------
* @Inherited：允许子类继承父类中的注解

--------

# 简单注解处理器
我们有时需要根据注解来做一些统计，来掌控项目进展。下面我们做一个小 Demo，来统计已实现的需求和未实现的需求。

首先定义注解，用 id 来区分方法，description 来存储一些方法说明，这一项不填即为默认值。

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface UseCase {
	public int id();
	public String description() default "no description";
}
```

接下来写一个待检查的方法：

```java
public class PassWordUtils {
	@UseCase(id=47,description=
			"密码最起码要有一个数字吧")
	public boolean validatePassword(String password){
		return (password.matches("\\w\\d\\w*"));
	}

	@UseCase(id=48)
	public String encryptPassword(String password){
		return new StringBuilder(password).reverse().toString();
	}

	@UseCase(id=49,description=
			"新密码不能和老密码这么像吧")
	public boolean checkForNewPassword(
			List<String> prevPasswords,String password){
		return !prevPasswords.contains(password);
	}
}
```
最后编写注解处理器，用来统计我们已经实现的方法和还未实现的方法。

```java
public class UseCaseTracker {
	public static void trackUseCases(List<Integer> useCases, Class<?> cl) {
		//遍历该类的所有方法
		for(Method m:cl.getDeclaredMethods()){
			//获取加在方法上的UseCase注解
			UseCase uc=m.getAnnotation(UseCase.class);
			if(uc!=null){//如果方法上确实有UseCase注解
				System.out.println("找到了用例:"+uc.id()+" "+uc.description());
				useCases.remove(new Integer(uc.id()));
			}
		}
		for(int i:useCases){
			System.out.println("警告：丢失用例:"+i);
		}
	}

	public static void main(String[] args) {
		List<Integer> useCases=new ArrayList<>();
		Collections.addAll(useCases, 47,48,49,50,51);
		trackUseCases(useCases, PassWordUtils.class);
	}
}
```
最后输出结果如下：

![输出结果](http://upload-images.jianshu.io/upload_images/3054656-d8f07f9703c165b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 注解处理器最佳实践
下面我们通过注解要实现的需求是：通过在 JavaBean 上加注解，生成对应的 SQL 语句。这类似于 JavaWeb 的某些框架，虽然是个十分简单的功能，但是却是这些框架的基本原理。
下面先定义一个注解，这个注解用来告诉注解处理器，你需要为我生成的数据库表名叫什么：
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface DBTable {
	public String name() default "";
}
```
接下来是数据库中的各个字段，你需要告诉处理器你的字段名、类型、是否为主键、是否唯一等等。
首先定义一个注解，用来告诉处理器你的字段约束。
```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Constraints {
	boolean primaryKey() default false;
	boolean allowNull() default true;
	boolean unique() default false;
}
```
接下来是字段类型，我们只选两个代表，String 和 Int。
```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SQLString {
	int value() default 0;
	String name() default "";
	Constraints constraints() default @Constraints;
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SQLInteger {
	String name() default "";
	Constraints constraints() default @Constraints;
}
```
下面是一个简单 Bean 的定义,用到了以上的注解：
```java
@DBTable(name = "STUDENT")
public class Student {
    @SQLString(value = 30, name = "studentname", constraints = @Constraints(allowNull = false))
    String name;

    @SQLString(value = 50, constraints = @Constraints(unique = true))
    String enjoy;

    @SQLInteger(constraints = @Constraints(allowNull = false))
    Integer age;

    @SQLString(value = 30, constraints = @Constraints(primaryKey = true))
    String teacherName;
}
```
最后是注解处理器，它将读取一个类文件，检查其上的数据库注解，并生成用来创建数据库的 SQL 命令：
```java
public class TableCreator {
    public static void main(String[] args) throws Exception {
            Class cl=Student.class;
            DBTable dbTable = (DBTable) cl.getAnnotation(DBTable.class);
            if (dbTable == null) {
                System.out.println(cl.getSimpleName() + "类不能生成一个数据库表格");
                return;
            }
            String tableName = dbTable.name();
            if (tableName.length() < 1) {
                tableName = cl.getSimpleName().toUpperCase();
            }
            List<String> columnDefs = new ArrayList<>();
            for (Field field : cl.getDeclaredFields()) {
                Annotation[] ans = field.getDeclaredAnnotations();
                if (ans.length < 1) continue;
                String columnName = null;
                if (ans[0] instanceof SQLInteger) {
                    SQLInteger sInt = (SQLInteger) ans[0];
                    if (sInt.name().length() < 1) {
                        columnName = field.getName().toUpperCase();
                    } else {
                        columnName = sInt.name().toUpperCase();
                    }
                    columnDefs.add(columnName + " INT " + getConstraints(sInt.constraints()));
                } else if (ans[0] instanceof SQLString) {
                    SQLString sString = (SQLString) ans[0];
                    if (sString.name().length() < 1) {
                        columnName = field.getName().toUpperCase();
                    } else {
                        columnName = sString.name().toUpperCase();
                    }
                    columnDefs.add(columnName + " VARCHAR(" + sString.value() + ") " + getConstraints(sString.constraints()));
                }
            }
            StringBuilder createCommand = new StringBuilder(
                    "CREATE TABLE " + tableName + "("
            );
            for (String columnDef : columnDefs) {
                createCommand.append("\n    " + columnDef + ",");
            }
            String tableCreate=createCommand.substring(0,createCommand.length()-1)+");";
            System.out.println("根据" + cl.getName() + "创建数据库：\n" + tableCreate);

    }

    private static String getConstraints(Constraints con) {
        String constraints = "";
        if (!con.allowNull()) {
            constraints += " NOT NULL ";
        }
        if (con.primaryKey()) {
            constraints += " PRIMARY KEY ";
        }
        if (con.unique()) {
            constraints += " UNIQUE ";
        }
        return constraints;
    }
}
```
我们实现的功能还很低级，如果你要改任何属性或者参数，都要重新编译 Java 代码，现在的很多框架都会生成 XML 文件，而不是 SQL 语句，但基本原理都是这样的。

# 最后
本篇文章只是 《Java 编程思想》的学习笔记，看了网上的很多资料，觉得还是这本书讲的最好。
