<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[aidl 浅析]]></title>
      <url>%2F2017%2F04%2F17%2Faidl%20%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Demo 地址https://github.com/jutao/aidlAIDL客户端 什么是AIDL在 Android中，每一个应用程序独自拥有一个虚拟机，这样做虽然保证了进程之内数据的安全性，保证一个应用程序的数据不受其他应用程序的影响，也保证了一个应用程序挂掉了不至于影响其他应用程序。但是这样也造成了一个应用程序和另外一个应用程序没办法直接进行通讯。AIDL 的作用就是使来自不同应用的客户端跨进程通信访问你的 Service。AIDL 是 Android Interface Definition Language 的缩写，就是安卓内部通信接口描述语言。关于 AIDL的描述和用法我主要参考了Google 的官方API，找到一个中文的，链接：http://www.android-doc.com/guide/components/aidl.html。需要补充的是，API里描述AIDL支持Java语言中的所有基本数据类型，但是经过查证和实验，实际上 AIDL 是不支持Short类型的。 AIDL用法创建 AIDL 接口如果是 Eclipse 的话需要创建 File 并且不要忘记自己打上后缀 .aidl。 写 AIDL 接口AIDL 的用法基本和写普通 Java 接口相同，需要注意的是包名一定要自己检查一下，还有导包也要自己写一下。 12345package com.example.jutao.aidl;interface IServiceAidl &#123;//计算两个数的和int add(int num1,int num2);&#125; 写完之后需要注意，如果你写的 AIDL 接口正确，那么 Ecipse 是会自动编译的，而 Android Studio 需要手动编译，编译按钮如下图所示： 编译通过后，Android Studio 所生成的文件在这里： 写 Service1234567891011//当客户端绑定到该服务的时候@Override public IBinder onBind(Intent intent) &#123; //当别人绑定服务的时候，就会得到AIDL接口 return iBinder;&#125;IBinder iBinder = new IServiceAidl.Stub() &#123; @Override public int add(int num1, int num2) throws RemoteException &#123; Log.d("TAG", "收到服务端请求,求出" + num1 + "和" + num2 + "的和"); return num1 + num2;&#125;&#125;; 1234567&lt;!-- exported 是否支持其它应用调用当前组件 --&gt;&lt;!-- enabled 这个属性用于指示该服务是否能够被实例化。如果设置为true，则能够被实例化，否则不能被实例化。默认值是true --&gt; &lt;service android:name="com.example.aidl_service.RemoteService" android:enabled="true" android:exported="true" &gt; &lt;/service&gt; 写客户端客户端的主要功能是用户通过界面输入两个数字，点击远程计算按钮后通过服务端代码计算出结果返回给客户端并显示。 点击按钮后 需要注意的是，客户端也需要有一模一样的 AIDL 包，连包名都要一模一样！！ 1234567//1、获取服务端Intent intent = new Intent();//Android 5.0之后不支持隐式意图，必须是显式意图来启动绑定服务intent.setComponent(new ComponentName("com.example.jutao.aidl", "com.example.jutao.aidl.RemoteService"));//第三个参数是一个flag，绑定时自动启动bindService(intent, conn, Context.BIND_AUTO_CREATE); conn的定义: 12345678910111213ServiceConnection conn = new ServiceConnection() &#123; //绑定服务时 @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //拿到了远程的服务 iServiceAidl = IServiceAidl.Stub.asInterface(service); &#125; //当服务断开时 @Override public void onServiceDisconnected(ComponentName name) &#123; //回收资源 iServiceAidl = null; &#125; &#125;; AIDL 自定义类型AIDL 默认支持的数据类型如上图所示，虽然支持List类型，但是需要 在List前注明输入List还是输出List，下面的例子会讲到。首先 person 类要实现 Parcelable 接口，详细代码可以在我开头贴的Demo里看。 1234567891011121314151617181920212223242526272829import com.example.jutao.aidl.Person;interface PersonAidl &#123; List&lt;Person&gt; add(in Person person);&#125;parcelable Person;public class PersonService extends Service &#123; private ArrayList&lt;Person&gt; persons; public PersonService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123;persons = new ArrayList&lt;Person&gt;();return iBinder; &#125; private IBinder iBinder = new PersonAidl.Stub() &#123;@Override public List&lt;Person&gt; add(Person person) throws RemoteException &#123; persons.add(person); return persons;&#125; &#125;;&#125; 可以看到，我每次输出的都是 persons 这一List，这是通过服务端返回的，说明我传输过去的值已经被服务端接收并存储。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Path 学习笔记之基本操作]]></title>
      <url>%2F2017%2F04%2F16%2FPath%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[path 常用方法一览 为了兼容性(偷懒) 本表格中去除了部分API21(即安卓版本5.0)以上才添加的方法。 作用 相关方法 备注 移动起点 moveTo 移动下一次操作的起点位置 设置终点 setLastPoint 重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同 连接直线 lineTo 添加上一个点到当前点之间的直线到Path 闭合路径 close 连接第一个点连接到最后一个点，形成一个闭合区域 添加内容 addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo 添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别) 是否为空 isEmpty 判断Path是否为空 是否为矩形 isRect 判断path是否是一个矩形 替换路径 set 用新的路径替换到当前路径所有内容 偏移路径 offset 对当前路径之前的操作进行偏移(不会影响之后的操作) 贝塞尔曲线 quadTo, cubicTo 分别为二次和三次贝塞尔曲线的方法 rXxx方法 rMoveTo, rLineTo, rQuadTo, rCubicTo 不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量) 填充模式 setFillType, getFillType, isInverseFillType, toggleInverseFillType 设置,获取,判断和切换填充模式 提示方法 incReserve 提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构) 布尔操作(API19) op 对两个Path进行布尔运算(即取交集、并集等操作) 计算边界 computeBounds 计算Path的边界 重置路径 reset, rewind 清除Path中的内容 reset不保留内部数据结构，但会保留FillType. rewind会保留内部的数据结构，但不保留FillType 矩阵操作 transform 矩阵变换 Path含义Path封装了由直线和曲线(二次，三次贝塞尔曲线)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，也可以用于剪裁画布和根据路径绘制文字。我们有时会用Path来描述一个图像的轮廓，所以也会称为轮廓线(轮廓线仅是Path的一种使用方法，两者并不等价) 直线与点的操作lineTo12345//创建一条从原点到坐标(300,300)的直线mPath.lineTo(500,500);//创建从(500,500)到(100,200)的一条直线mPath.lineTo(100,200); 效果如下： 所以可知 lineTo 方法的连接的起点是由lineTo方法上一个Path操作决定的。 moveTo123//这样改写的话是画一条从(500,500)到(100,200)的线mPath.moveTo(500,500);mPath.lineTo(100,200); 效果如下: 所以可知 moveTo 方法的作用为将下次画路径起点移动到(x,y) setLastPoint123mPath.lineTo(300,300);mPath.setLastPoint(200,200);mPath.lineTo(200,400); 效果如下: 所以可知 setLastPoint 的作用为改变上一次操作路径的结束坐标点。 因此我们可以总结出 moveTo 和 lineTo 的区别为： moveTo 影响上一次操作不影响上一次 setLastPoint上一次和下一次操作都影响 close1234mPath.lineTo(300,300);mPath.setLastPoint(200,200);mPath.lineTo(200,400);mPath.close(); 效果如下： 观察可知 close 的效果为用线段连接起始点和终点，除非起始点等于终点。 基本形状addRect（矩形）123mPath.addRect(50,50,150,150,Direction.CW);mPath.addRect(50,250,150,350,Direction.CCW); 效果如下： 上下两个方法画出来的一模一样，那他们有什么区别呢？我们试着用一下刚学的 setLastPoint 看效果。 123456mPath.addRect(50,50,150,150,Direction.CW);//改变最后一笔的位置mPath.setLastPoint(50,100);mPath.addRect(50,250,150,350,Direction.CCW);mPath.setLastPoint(150,300); 效果如下： 所以我们可以看出 Direction.CW 的最后一笔是左下角，Direction.CCW 的最后一笔是右上角，而且 Android 源码中给 Direction.CW 的注释为 clockwise(顺时针),Direction.CCW 的注释为 counter-clockwise(逆时针),通过这些我们可以很清楚的知道以上两种矩形画法的区别。 而矩形的另外一种画法 public void addRect(RectF rect, Direction dir) 和上面的方法其实一样，只是把坐标封装到了 RectF 对象中而已。 addCircle（圆形）123mPath.addCircle(210,210,200, Path.Direction.CW);mPath.addCircle(800,800,200, Path.Direction.CCW); 效果如下： 画圆非常简单，x，y 代表圆心坐标，radius 代表半径，dir 和矩形一样，代表顺时针或者逆时针。 12345mPath.addCircle(210,210,200, Path.Direction.CW);mPath.setLastPoint(210,210);mPath.addCircle(800,800,200, Path.Direction.CCW);mPath.setLastPoint(800,800); 效果如下： addRoundRect（圆角矩形）圆角矩形主要有两种画法，一种是圆角弧度统一，第二种是定制每一个圆角的弧度。用法如下: 12345678910mPath = new Path();mPath.addRoundRect(rect1,100,100, Path.Direction.CW);RectF rect2=new RectF(100,600,800,1000);/*必须传入8个数值，分四组，分别对应每个角所使用的椭圆的横轴半径和纵轴半径， 如｛x1,y1,x2,y2,x3,y3,x4,y4｝，其中，x1,y1对应第一个角的（左上角）用来产 生圆角的椭圆的横轴半径和纵轴半径，其它类推……*/float[] radii=&#123;100,100,150,150,200,200,300,200&#125;;mPath.addRoundRect(rect2,radii,Path.Direction.CCW); 效果如下： 我标了一下每个圆角半径，很丑： addOval（椭圆）123456RectF rect = new RectF(100, 100, 800, 500);mPath = new Path();mPath.addOval(rect, Path.Direction.CW);//将矩形变为正方形看效果rect = new RectF(100, 600, 300, 800);mPath.addOval(rect, Path.Direction.CW); 效果如下： addArc与arcTo（圆弧）1234567RectF rect = new RectF(100, 100, 800, 500);//开始的角度float startAngle=90;//扫过的角度float sweepAngle=180;mPath = new Path();mPath.addArc(rect,startAngle,sweepAngle); 效果： 关于起始角度以及扫过的角度这些是怎么来的，我理解的是实际上我们是在指定矩形内画一个内切椭圆，通过指定角度在这个椭圆上截取一部分，这一部分就是我们所画的弧。示意图如下，不要嫌丑： 知道了addArc的用法之后，我们来看一下arcTo这个方法，这个方法也是用来画圆弧的，但是与addArc有些不同: addArc 直接添加一段圆弧 arcTo 添加一段圆弧，如果圆弧的起点与上一次Path操作的终点不一样的话，就会在这两个点连成一条直线 12345678RectF rect = new RectF(100, 100, 800, 500);//开始的角度float startAngle=90;//扫过的角度float sweepAngle=180;mPath = new Path();mPath.lineTo(100,100);mPath.arcTo(rect,startAngle,sweepAngle); 效果如下： 可以看到，圆弧的起点并不是直线的终点，于是他们连接在了一起。如果你不想让他们连接怎么办？ mPath.arcTo(rect,startAngle,sweepAngle,true); arcTo 最后一个属性填 true 就可以了。效果如下： addPath（添加Path）先看最普通的 public void addPath (Path src) 123456Path circle=new Path();RectF rect = new RectF(100, 100, 800, 500);mPath = new Path();mPath.addRect(rect, Path.Direction.CW);circle.addCircle(450,300,200, Path.Direction.CW);mPath.addPath(circle); 它将两个path合并在了一起，效果如下： addPath的第二个方法的 dx 和 dy 两个参数是什么意思呢？ 1mPath.addPath(circle,350,-100); 其实它们是代表添加path后的位移值 效果如下： 设置方法set()123456Path circle=new Path();RectF rect = new RectF(100, 100, 800, 500);mPath = new Path();mPath.addRect(rect, Path.Direction.CW);circle.addCircle(450,300,200, Path.Direction.CW);mPath.set(circle); 这个方法就是将path之前的矩形变成圆形。 效果如下： offset()1234RectF rect = new RectF(100, 100, 800, 500);mPath = new Path();mPath.addRect(rect, Path.Direction.CW);mPath.offset(150,150); 它的作用就是将path进行平移 offset() 还有一个参数 dst 是起什么作用呢？ 1234567mPath=new Path();mPath.addCircle(50,50,200, Path.Direction.CW);Path temp=new Path();RectF rect = new RectF(100, 100, 800, 500);temp.addRect(rect, Path.Direction.CW);//相当于用set方法将 temp set 给了mPath，覆盖 mPath 原有的图案temp.offset(150,150,mPath); 效果如下： 可以看到 mPath 之前画的圆已经被覆盖 reset()这个方法很简单，就是将path的所有操作都清空掉。 判断方法isConvex()（这个方法在API21之后才有）判断path是否为凸多边形，如果是就为true，反之为false。 要理解这个方法首先，我们要知道什么是凸多边形。 凸多边形的概念: 每个内角小于180度 任何两个顶点间的线段位于多边形的内部或边界上。 也就是说矩形，三角形，直线都是凸多边形，但是五角星那种形状就不是。现在我们用代码验证一下： 1234567mPath=new Path();mPath.moveTo(100,100);mPath.lineTo(200,200);mPath.lineTo(100,400);mPath.lineTo(300,50);mPath.close();System.out.println(mPath.isConvex()); 效果如下： 很明显，这不是一个凸多边形，查看输出：1I/System.out: false isEmpty这个方法依然很简单，就是判断 path 中是否包含内容 1234mPath=new Path();System.out.println(mPath.isEmpty());mPath.lineTo(300,50);System.out.println(mPath.isEmpty()); 查看输出：12I/System.out: trueI/System.out: false isRect12345mPath=new Path();RectF rect=new RectF();mPath.addRect(100,100,50,50,Path.Direction.CW);System.out.println(mPath.isRect(rect));System.out.println(rect); 判断path是否是一个矩形，如果是一个矩形的话，将矩形的信息存到参数rect中。 输出如下： 12I/System.out: trueI/System.out: RectF(50.0, 50.0, 100.0, 100.0) 最佳实践如果想练习一下 Path知识，可以看一下下面的 blog： Path实战之雷达图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Path 学习笔记之基本操作]]></title>
      <url>%2F2017%2F04%2F16%2FPath%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BBezier%2F</url>
      <content type="text"><![CDATA[贝塞尔曲线能干什么？贝塞尔曲线的运用是十分广泛的，可以说贝塞尔曲线奠定了计算机绘图的基础(因为它可以将任何复杂的图形用精确的数学语言进行描述)，在你不经意间就已经使用过它了。 你会使用Photoshop的话，你可能会注意到里面有一个钢笔工具，这个钢笔工具核心就是贝塞尔曲线。 你说你不会PS？ 没关系，你如果看过前面的文章或者用过2D绘图，肯定绘制过圆，圆弧，圆角矩形等这些东西。这里面的圆弧部分全部都是贝塞尔曲线的运用。 贝塞尔曲线作用十分广泛，简单举几个的栗子: QQ小红点拖拽效果 一些炫酷的下拉刷新控件 阅读软件的翻书效果 一些平滑的折线图的制作 很多炫酷的动画效果 贝塞尔曲线的原理贝塞尔曲线是用一系列点来控制曲线状态的，我将这些点简单分为两类： 类型 作用 数据点 确定曲线的起始和结束位置 控制点 确定曲线的弯曲程度 此处暂时仅作了解概念，接下来就会讲解其中详细的含义。 一阶曲线原理一阶曲线是没有控制点的，仅有两个数据点(A 和 B)，最终效果一个线段。 上图表示的是一阶曲线生成过程中的某一个阶段，动态过程可以参照下图(本文中贝塞尔曲线相关的动态演示图片来自维基百科)。 PS：一阶曲线其实就是 Path 的 lineTo 方法。 二阶曲线原理二阶曲线由两个数据点(A 和 C)，一个控制点(B)来描述曲线状态，大致如下： 上图中红色曲线部分就是传说中的二阶贝塞尔曲线，那么这条红色曲线是如何生成的呢？接下来我们就以其中的一个状态分析一下： 连接AB BC，并在AB上取点D，BC上取点E，使其满足条件： 连接DE，取点F，使得: 这样获取到的点F就是贝塞尔曲线上的一个点，动态过程如下： PS: 二阶曲线对应的方法是quadTo 三阶曲线原理三阶曲线由两个数据点(A 和 D)，两个控制点(B 和 C)来描述曲线状态，如下： 三阶曲线计算过程与二阶类似，具体可以见下图动态效果： PS: 三阶曲线对应的方法是cubicTo 其他 贝塞尔曲线速查表 强烈推荐点击这里练习贝塞尔曲线，可以加深对贝塞尔曲线的理解程度。 贝塞尔曲线基本用法一阶曲线一阶曲线是一条线段，非常简单，可以参见上一篇文章Path之基本操作，此处就不详细讲解了。 二阶曲线代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class Bezier extends View&#123; private Paint mPaint; private PointF start,end,control; private int centerX,centerY; public Bezier(Context context) &#123; this(context,null); &#125; public Bezier(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs,0); &#125; public Bezier(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; start=new PointF(0,0); end=new PointF(0,0); control=new PointF(0,0); mPaint=new Paint(); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(8); mPaint.setTextSize(60); mPaint.setAntiAlias(true); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); centerX=w/2; centerY=h/2; start.x=centerX-200; start.y=centerY; end.x=centerX+200; end.y=centerY; control.x=centerX; control.y=centerY-100; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); drawPoint(canvas); drawAuxiliaryLine(canvas); drawBezierPath(canvas); &#125; /** * 绘制数据点和控制点 */ private void drawPoint(Canvas canvas) &#123; mPaint.setColor(Color.GRAY); canvas.drawCircle(start.x,start.y,4,mPaint); canvas.drawCircle(end.x,end.y,4,mPaint); canvas.drawCircle(control.x,control.y,4,mPaint); &#125; /** * 绘制辅助线 */ private void drawAuxiliaryLine(Canvas canvas) &#123; mPaint.setStrokeWidth(4); canvas.drawLine(start.x,start.y,control.x,control.y,mPaint); canvas.drawLine(end.x,end.y,control.x,control.y,mPaint); &#125; /** * 绘制二阶曲线 */ private void drawBezierPath(Canvas canvas) &#123; mPaint.setColor(Color.RED); mPaint.setStrokeWidth(8); Path path=new Path(); path.moveTo(start.x,start.y); path.quadTo(control.x,control.y,end.x,end.y); canvas.drawPath(path,mPaint); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; control.x=event.getX(); control.y=event.getY(); postInvalidate(); return true; &#125;&#125; 效果如下： 三阶曲线代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class Bezier2 extends View&#123; private Paint mPaint; private PointF start,end,control1,control2; private int centerX,centerY; private boolean isControl1=true; public Bezier2(Context context) &#123; this(context,null); &#125; public Bezier2(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs,0); &#125; public Bezier2(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; start=new PointF(0,0); end=new PointF(0,0); control1=new PointF(0,0); control2=new PointF(0,0); mPaint=new Paint(); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(8); mPaint.setTextSize(60); mPaint.setAntiAlias(true); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); centerX=w/2; centerY=h/2; start.x=centerX-300; start.y=centerY; end.x=centerX+300; end.y=centerY; control1.x=centerX-100; control1.y=centerY-200; control2.x=centerX+100; control2.y=centerY-200; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); drawPoint(canvas); drawAuxiliaryLine(canvas); drawBezierPath(canvas); &#125; /** * 绘制数据点和控制点 */ private void drawPoint(Canvas canvas) &#123; mPaint.setColor(Color.GRAY); canvas.drawCircle(start.x,start.y,4,mPaint); canvas.drawCircle(end.x,end.y,4,mPaint); canvas.drawCircle(control1.x,control1.y,4,mPaint); canvas.drawCircle(control2.x,control2.y,4,mPaint); &#125; /** * 绘制辅助线 */ private void drawAuxiliaryLine(Canvas canvas) &#123; mPaint.setStrokeWidth(4); canvas.drawLine(start.x,start.y,control1.x,control1.y,mPaint); canvas.drawLine(end.x,end.y,control2.x,control2.y,mPaint); canvas.drawLine(control1.x,control1.y,control2.x,control2.y,mPaint); &#125; /** * 绘制三阶曲线 */ private void drawBezierPath(Canvas canvas) &#123; mPaint.setColor(Color.RED); mPaint.setStrokeWidth(8); Path path=new Path(); path.moveTo(start.x,start.y); path.cubicTo(control1.x,control1.y,control2.x,control2.y,end.x,end.y); canvas.drawPath(path,mPaint); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if(isControl1)&#123; control1.x=event.getX(); control1.y=event.getY(); &#125;else &#123; control2.x=event.getX(); control2.y=event.getY(); &#125; postInvalidate(); return true; &#125; public void isControl1(boolean control1) &#123; isControl1 = control1; &#125;&#125; 主要的区别就是多了一个控制点，效果如下： 降阶与升阶 三阶曲线相比于二阶曲线可以制作更加复杂的形状，但是对于高阶的曲线，用低阶的曲线组合也可达到相同的效果，就是传说中的降阶。因此我们对贝塞尔曲线的封装方法一般最高只到三阶曲线。 类型 释义 变化 降阶 在保持曲线形状与方向不变的情况下，减少控制点数量，即降低曲线阶数 方法变得简单，数据点变多，控制点可能减少，灵活性变弱 升阶 在保持曲线形状与方向不变的情况下，增加控制点数量，即升高曲线阶数 方法更加复杂，数据点不变，控制点增加，灵活性变强 贝塞尔曲线使用实例在制作这个实例之前，首先要明确一个内容，就是在什么情况下需要使用贝塞尔曲线？ 需要绘制不规则图形时？ 当然不是！目前来说，使用贝塞尔曲线主要有以下几个方面(摘抄) 序号 内容 用例 1 事先不知道曲线状态，需要实时计算时 天气预报气温变化的平滑折线图 2 显示状态会根据用户操作改变时 QQ小红点，仿真翻书效果 3 一些比较复杂的运动状态(配合PathMeasure使用) 复杂运动状态的动画效果 至于只需要一个静态的曲线图形的情况，用图片岂不是更好，大量的计算会很不划算。 如果是显示SVG矢量图的话，已经有相关的解析工具了(内部依旧运用的有贝塞尔曲线)，不需要手动计算。 贝塞尔曲线的主要优点是可以实时控制曲线状态，并可以通过改变控制点的状态实时让曲线进行平滑的状态变化。 我们要实现的效果是使一个圆渐变为心形 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class BezierHeartView extends View &#123; // 一个常量，用来计算绘制圆形贝塞尔曲线控制点的位置 private static final float C = 0.551915024494f; private int mCenterX; private int mCenterY; //圆的半径 private float mCircleRadius = 200; // 圆形的控制点与数据点的差值 private float mDifference = mCircleRadius * C; private Paint mPaint; // 顺时针记录绘制圆形的四个数据点 private float[] mData = new float[8]; // 顺时针记录绘制圆形的八个控制点 private float[] mCtrl = new float[16]; private Paint mFuZhuPaint; // 变化总时长 private float mDuration = 1000; // 当前已进行时长 private float mCurrent = 0; // 将时长总共划分多少份 private float mCount = 100; // 每一份的时长 private float mPiece = mDuration / mCount; public BezierHeartView(Context context) &#123; this(context, null); &#125; public BezierHeartView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public BezierHeartView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(8); mPaint.setStyle(Paint.Style.STROKE); mPaint.setTextSize(60); mFuZhuPaint = new Paint(); mFuZhuPaint.setStrokeWidth(5); mFuZhuPaint.setColor(Color.RED); mFuZhuPaint.setStyle(Paint.Style.STROKE); //初始化数据点 mData[0] = 0; mData[1] = mCircleRadius; mData[2] = mCircleRadius; mData[3] = 0; mData[4] = 0; mData[5] = -mCircleRadius; mData[6] = -mCircleRadius; mData[7] = 0; //初始化控制点 mCtrl[0] = mData[0] + mDifference; mCtrl[1] = mData[1]; mCtrl[2] = mData[2]; mCtrl[3] = mData[3] + mDifference; mCtrl[4] = mData[2]; mCtrl[5] = mData[3] - mDifference; mCtrl[6] = mData[4] + mDifference; mCtrl[7] = mData[5]; mCtrl[8] = mData[4] - mDifference; mCtrl[9] = mData[5]; mCtrl[10] = mData[6]; mCtrl[11] = mData[7] - mDifference; mCtrl[12] = mData[6]; mCtrl[13] = mData[7] + mDifference; mCtrl[14] = mData[0] - mDifference; mCtrl[15] = mData[1]; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mCenterX = w / 2; mCenterY = h / 2; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制坐标系 drawCoordinateSystem(canvas); //绘制辅助线 drawAuxiliaryLine(canvas); // 绘制贝塞尔曲线 drawBezier(canvas); //幻化为心 changeBezier(canvas); &#125; private void changeBezier(Canvas canvas) &#123; mCurrent+=mPiece; if(mCurrent&lt;=mDuration)&#123; mData[1]+=120/mCount; mData[5]+=150/mCount; mCtrl[0]-=80/mCount; mCtrl[14]+=80/mCount; mCtrl[4]-=20/mCount; mCtrl[10]+=20/mCount; postInvalidateDelayed((long) mPiece); &#125; &#125; private void drawBezier(Canvas canvas) &#123; mPaint.setColor(Color.RED); mPaint.setStrokeWidth(8); mPaint.setStyle(Paint.Style.STROKE); Path path = new Path(); path.moveTo(mData[0], mData[1]); for (int i = 2, j = 0; j &lt; mCtrl.length; i += 2, j += 4) &#123; path.cubicTo(mCtrl[j], mCtrl[j + 1], mCtrl[j + 2], mCtrl[j + 3], mData[i % mData.length], mData[(i + 1) % mData.length]); &#125; canvas.drawPath(path, mPaint); &#125; private void drawAuxiliaryLine(Canvas canvas) &#123; mPaint.setColor(Color.GRAY); mPaint.setStrokeWidth(2); mPaint.setStyle(Paint.Style.FILL); for (int i = 0, j = 0; i &lt; mData.length; i += 2, j += 4) &#123; canvas.drawCircle(mData[i], mData[i + 1], 4, mPaint); canvas.drawCircle(mCtrl[j], mCtrl[j + 1], 4, mPaint); canvas.drawCircle(mCtrl[j + 2], mCtrl[j + 3], 4, mPaint); &#125; for (int i = 0, j = 0; j &lt; mCtrl.length; i += 2, j += 4) &#123; canvas.drawLine(mData[i], mData[i + 1], mCtrl[j], mCtrl[j + 1], mPaint); canvas.drawLine(mCtrl[j], mCtrl[j + 1], mCtrl[j + 2], mCtrl[j + 3], mPaint); canvas.drawLine(mCtrl[j + 2], mCtrl[j + 3], mData[(i + 2) % mData.length], mData[(i + 3) % mData.length], mPaint); &#125; &#125; private void drawCoordinateSystem(Canvas canvas) &#123; canvas.drawLine(0, mCenterY, mCenterX * 2, mCenterY, mFuZhuPaint); canvas.drawLine(mCenterX, 0, mCenterX, mCenterY * 2, mFuZhuPaint); canvas.translate(mCenterX, mCenterY); &#125;&#125; 预览效果： 参考资料Path之贝塞尔曲线]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-策略模式]]></title>
      <url>%2F2017%2F04%2F16%2F%5BAndroid%5D%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[最简单的商场收银软件如果要做一款收银软件，营业员根据客户所购买商品单价和数量向客户收费，这非常容易。 Demo 如下： 点击确定后的代码逻辑如下: 1234567891011121314151617181920212223242526272829private void doEnter() &#123;String stringTotal = tv_total.getText().toString().trim();double total;if (stringTotal != null &amp;&amp; stringTotal != "") &#123; total = Double.valueOf(stringTotal);&#125; else &#123; total = 0.0d;&#125;String stringDJ = et_dj.getText().toString().trim();String stringSL = et_sl.getText().toString().trim();if (stringDJ != null &amp;&amp; !stringDJ.equals("") &amp;&amp; stringSL != null &amp;&amp; !stringSL.equals("")) &#123; Log.d("TAG", "123" + stringDJ + "123"); double price = Double.valueOf(stringDJ); int number = Integer.valueOf(stringSL); double totalPrice = price * number; total = total + totalPrice; tv_total.setText(String.valueOf(total)); String text = tv_detail.getText().toString() + "单价： " + price + " 数量：" + number + " 合计:" + totalPrice + "\n"; tv_detail.setText(text);&#125;&#125; 增加打折功能后的收银软件可是如果商场搞促销，需要打折该怎么办，不可能每次都要修改代码然后重新安装，用下拉框可能会比较方便。Demo 如下： 添加的代码如下：1234567891011 switch (sp_jsfs.getSelectedItemPosition())&#123; case 1: totalPrice*=0.8; break; case 2: totalPrice*=0.7; break; case 3: totalPrice*=0.5; break;&#125; 这样看似解决了问题，但是需求不断增加，比如满300返50之类，这样的代码未免显得太过重复。接下来我们试着用简单工厂模式来解决问题试试。 简单工厂实现 面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象抽象集合才是类。 打一折和九折只是形式的不同，抽象分析出来，所有打折算法都是一样的，所以打折算法应该是一个类。返现算法也是一个类。 MainActivity 改动如下： 12CashSuper cSuper= CashFactor.createCashAccept(sp_jsfs.getSelectedItemPosition());totalPrice=cSuper.acceptCash(totalPrice); 详细代码可以去最后上传的Demo里看 简单工厂模式虽然也能解决问题，但只是解决对象创建的问题，而且由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折和返利额度，每次维护或扩展收费方式都要改动这个工厂，以至代码要重新编译部署，这是很糟糕的，所以我们需要另一种新的设计模式–策略模式。 策略模式什么是策略模式 策略模式就是定义一系列算法，把他们独立封装起来，并且这些算法之间可以相互替换。策略模式主要是管理一堆有共性的算法，客户端可以根据需要，很快切换这些算法，并且保持可扩展性。策略模式的本质：分离算法，选择实现。 如何运用到收银系统中商场收银如何促销，用打折还是返利，其实都是一些算法，用工厂来生成算法对象，这没有错，但算法本身只是一种策略，最重要的是这些算法是随时都可能互相替换的，这是变化点，而封装变化点是我们面向对象的一种很重要的思维方式。 以下是策略模式 UML 图 接下来我们将策略模式运用到收银系统中 首先创建一个 CashContext 代码如下： 1234567891011public class CashContext &#123; private CashSuper cs; public CashContext(CashSuper cs) &#123; this.cs = cs; &#125; public double GetResule(double money)&#123; return cs.acceptCash(money); &#125;&#125; 然后改动 MainActivity 如下： 12345678910111213141516171819CashContext cc = null; switch (sp_jsfs.getSelectedItemPosition()) &#123; case 0: cc = new CashContext(new CashNormal()); break; case 1: cc = new CashContext(new CashReturn(300, 100)); break; case 2: cc = new CashContext(new CashRebate(0.8)); break; case 3: cc = new CashContext(new CashRebate(0.7)); break; case 4: cc = new CashContext(new CashRebate(0.5)); break; &#125; totalPrice = cc.GetResule(totalPrice); 这时候，你会发现，我们又像原来一样在 MainActivity 中写了判断，可以试着将之前的工厂模式和策略模式结合吗？ 策略模式与简单工厂结合将 CashContext 类的构造方法修改如下： 12345678910111213141516171819public CashContext(int type) &#123; switch (type) &#123; case 0: cs=new CashNormal(); break; case 1: cs=new CashReturn(300,100); break; case 2: cs = new CashRebate(0.8); break; case 3: cs = new CashRebate(0.7); break; case 4: cs = new CashRebate(0.5); break; &#125; &#125; MainActivity 代码修改如下： 123CashContext cc = new CashContext(sp_jsfs.getSelectedItemPosition()); totalPrice = cc.GetResule(totalPrice); total = total + totalPrice; 这样客户端只需要认识一个类 CashContext就可以了，耦合度进一步降低了。不过这样一旦需求变化依旧需要修改 switch ，其实想要更好的实现可以用反射方法，具体用法下次再做讨论。 Demo策略模式 Demo 参考文献《大话设计模式》 安卓设计模式–策略模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Path 实战]]></title>
      <url>%2F2017%2F04%2F15%2FPath%E5%AE%9E%E6%88%98%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[准备我们将从0到1一步一步来画一个 web 页面很常见的雷达图 第一步：绘制蜘蛛网络1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void init() &#123; mainPaint=new Paint(); mainPaint.setColor(Color.BLACK); mainPaint.setAntiAlias(true); mainPaint.setStrokeWidth(1); mainPaint.setStyle(Paint.Style.STROKE);&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; radius=Math.min(w,h)/2*0.9f; centerX=w/2; centerY=h/2; //一旦size发生改变，重新绘制 postInvalidate(); super.onSizeChanged(w, h, oldw, oldh);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; drawPolygon(canvas);&#125;/** * 绘制多边形 * @param canvas */private void drawPolygon(Canvas canvas)&#123; Path path=new Path(); //1度=1*PI/180 360度=2*PI 那么我们每旋转一次的角度为2*PI/内角个数 //中心与相邻两个内角相连的夹角角度 angle= (float) (2*Math.PI/count); //每个蛛丝之间的间距 float r= radius/(count-1); for (int i = 0; i &lt; count; i++) &#123; //当前半径 float curR=r*i; path.reset(); for (int j = 0; j &lt; count; j++) &#123; if(j==0)&#123; path.moveTo(centerX+curR,centerY); &#125;else &#123; //对于直角三角形sin(x)是对边比斜边，cos(x)是底边比斜边，tan(x)是对边比底边 //因此可以推导出:底边(x坐标)=斜边(半径)*cos(夹角角度) // 对边(y坐标)=斜边(半径)*sin(夹角角度) float x = (float) (centerX+curR*Math.cos(angle*j)); float y = (float) (centerY+curR*Math.sin(angle*j)); path.lineTo(x,y); &#125; &#125; path.close(); canvas.drawPath(path,mainPaint); &#125; 绘制蜘蛛网络其实就是绘制指定边数的正多边形，这一步比较简单，比较难的可能就是每个顶点的算法，相关注释我都写了，还有一张来自互联网的图以助于思考，如下： 绘制出的多边形成品如下: 动画效果只是写了 set 方法，用 handler 实现,代码如下： 1234567891011//设置数值种类public void setCount(int count) &#123; this.count = count; postInvalidate();&#125;//设置蜘蛛网颜色public void setMainPaint(Paint mainPaint) &#123; this.mainPaint = mainPaint; postInvalidate();&#125; 调用方法: 12345678910111213141516mainPaint=new Paint();mainPaint.setAntiAlias(true);mainPaint.setStrokeWidth(1);mainPaint.setStyle(Paint.Style.STROKE);Handler handler=new Handler();for (int i = 3; i &lt; 20; i++) &#123;final int finalI = i;handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mRdv.setCount(finalI); mainPaint.setStrokeWidth(finalI); mRdv.setMainPaint(mainPaint); &#125;&#125;,i*300);&#125; 第二步：绘制对角线1234567891011121314/** * 绘制直线 */private void drawLines(Canvas canvas)&#123; Path path=new Path(); for (int i = 0; i &lt; count; i++) &#123; path.reset(); path.moveTo(centerX,centerY); float x = (float) (centerX+radius*Math.cos(angle*i)); float y = (float) (centerY+radius*Math.sin(angle*i)); path.lineTo(x,y); canvas.drawPath(path,mainPaint); &#125;&#125; 这一步比较简单，就是将中心点和各个顶点连接起来，效果如下: 第三步：绘制标题文字12345678910111213141516171819202122232425262728293031323334353637/** * 绘制标题文字 * * @param canvas */private void drawTitle(Canvas canvas) &#123; if (count != titles.size()) &#123; return; &#125; //相关知识点:http://mikewang.blog.51cto.com/3826268/871765/ Paint.FontMetrics fontMetrics = textPaint.getFontMetrics(); float fontHeight = fontMetrics.descent - fontMetrics.ascent; //绘制文字时不让文字和雷达图形交叉,加大绘制半径 float textRadius = radius + fontHeight; double pi = Math.PI; for (int i = 0; i &lt; count; i++) &#123; float x = (float) (centerX + textRadius * Math.cos(angle * i)); float y = (float) (centerY + textRadius * Math.sin(angle * i)); //当前绘制标题所在顶点角度 float degrees = angle * i; //从右下角开始顺时针画起,与真实坐标系相反 if (degrees &gt;= 0 &amp;&amp; degrees &lt; pi / 2) &#123;//第四象限 float dis=textPaint.measureText(titles.get(i))/(titles.get(i).length()-1); canvas.drawText(titles.get(i), x+dis, y, textPaint); &#125; else if (degrees &gt;= pi / 2 &amp;&amp; degrees &lt; pi) &#123;//第三象限 float dis=textPaint.measureText(titles.get(i))/(titles.get(i).length()-1); canvas.drawText(titles.get(i), x-dis, y, textPaint); &#125; else if (degrees &gt;= pi &amp;&amp; degrees &lt; 3 * pi / 2) &#123;//第二象限 float dis=textPaint.measureText(titles.get(i))/(titles.get(i).length()); canvas.drawText(titles.get(i), x-dis, y, textPaint); &#125; else if (degrees &gt;= 3 * pi / 2 &amp;&amp; degrees &lt;= 2 * pi) &#123;//第一象限 canvas.drawText(titles.get(i), x, y, textPaint); &#125; &#125;&#125; 效果如下： 第四步：绘制覆盖区域要绘制覆盖区域，首先要指定最大值和每个分类的具体数值,有了这些数值之后，就可以绘制了。 代码如下： 12345678910111213141516171819202122232425262728293031/** * 绘制覆盖区域 */private void drawRegion(Canvas canvas)&#123; valuePaint.setAlpha(255); Path path=new Path(); for (int i = 0; i &lt; count; i++) &#123; //计算该数值与最大值比例 Double perCenter = data.get(i)/maxValue; //小圆点所在位置距离圆心的距离 double perRadius=perCenter*radius; float x = (float) (centerX + perRadius * Math.cos(angle * i)); float y = (float) (centerY + perRadius * Math.sin(angle * i)); if(i==0)&#123; path.moveTo(x,y); &#125;else &#123; path.lineTo(x,y); &#125; //绘制小圆点 canvas.drawCircle(x,y,10,valuePaint); &#125; //闭合覆盖区域 path.close(); valuePaint.setStyle(Paint.Style.STROKE); //绘制覆盖区域外的连线 canvas.drawPath(path, valuePaint); //填充覆盖区域 valuePaint.setAlpha(128); valuePaint.setStyle(Paint.Style.FILL); canvas.drawPath(path,valuePaint);&#125; 看一下效果： 再来看一下动态的效果吧： 总结终于完成了,全部代码在下面： Android雷达图全部代码 主要是参考 crazy__chen 大神的博客，链接贴在下面，做了一遍其实还蛮简单的，这个控件还有很多不完善的，如果实际使用需要改善的地方还有很多，如果有不足希望大家可以告诉我，谢谢！！ 参考资料 Android雷达图(蜘蛛网图)绘制 Path之基本操作]]></content>
    </entry>

    
  
  
</search>
