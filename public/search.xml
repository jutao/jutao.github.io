<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
<<<<<<< HEAD
=======
      <title><![CDATA[旋转字符串]]></title>
      <url>%2F2017%2F07%2F12%2F%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[题目描述给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。 分析与解法解法一：暴力移位法初看此题，可能最先想到的方法是按照题目所要求的，把需要移动的字符一个一个地移动到字符串的尾部，如此我们可以实现一个函数LeftShiftOne(char[] chars, int n) ，以完成移动一个字符到字符串尾部的功能，代码如下所示： 12345678910111213 void leftRotateString(char[] chars, int n, int m) &#123; while ((m--)!=0)&#123; leftShiftOne(chars,n); &#125;&#125; void leftShiftOne(char[] chars, int n) &#123; char t = chars[0]; for (int i = 1; i &lt; n; i++) &#123; chars[i - 1] = chars[i]; &#125; chars[n - 1] = t;&#125; 下面，我们来分析一下这种方法的时间复杂度和空间复杂度。 针对长度为n的字符串来说，假设需要移动m个字符到字符串的尾部，那么总共需要 mn 次操作，同时设立一个变量保存第一个字符，如此，时间复杂度为O(m n)，空间复杂度为O(1)，空间复杂度符合题目要求，但时间复杂度不符合，所以，我们得需要寻找其他更好的办法来降低时间复杂度。 解法二：三步反转法对于这个问题，换一个角度思考一下。 将一个字符串分成X和Y两个部分，在每部分字符串上定义反转操作，如X^T，即把X的所有字符反转（如，X=”abc”，那么X^T=”cba”），那么就得到下面的结论：(X^TY^T)^T=YX，显然就解决了字符串的反转问题。 例如，字符串 abcdef ，若要让def翻转到abc的前头，只要按照下述3个步骤操作即可： 首先将原字符串分为两个部分，即X:abc，Y:def；将X反转，X-&gt;X^T，即得：abc-&gt;cba；将Y反转，Y-&gt;Y^T，即得：def-&gt;fed。反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。如下图所示： 代码则可以这么写：123456789101112131415161718192021/** * 将长度为n的字符串s的前m个字符移动到字符串尾部 */static void leftRotateString(char[] chars, int n, int m) &#123;// 若要左移动大于n位，那么和%n 是等价的 m %= n; reverseString(chars, 0, m - 1); reverseString(chars, m, n - 1); reverseString(chars, 0, n - 1);&#125;/** * 翻转字符数组from-to之间的字符串 */static void reverseString(char[] chars, int from, int to) &#123; while (from &lt; to) &#123; char c = chars[from]; chars[from++] = chars[to]; chars[to--] = c; &#125;&#125; 这就是把字符串分为两个部分，先各自反转再整体反转的方法，时间复杂度为O(n)，空间复杂度为O(1)，达到了题目的要求。 举一反三1、链表翻转。给出一个链表和一个数k，比如，链表为1→2→3→4→5→6，k=2，则翻转后2→1→6→5→4→3，若k=3，翻转后3→2→1→6→5→4，若k=4，翻转后4→3→2→1→6→5，用程序实现。 2、编写程序，在原字符串中把字符串尾部的m个字符移动到字符串的头部，要求：长度为n的字符串操作时间复杂度为O(n)，空间复杂度为O(1)。 例如，原字符串为”Ilovebaofeng”，m=7，输出结果为：”baofengIlove”。 3、单词翻转。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变，句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。例如，输入“I am a student.”，则输出“student. a am I”。]]></content>
    </entry>

    
    <entry>
>>>>>>> 333dba136f4dcd9284a99e103790547582a4811f
      <title><![CDATA[了解注解]]></title>
      <url>%2F2017%2F07%2F12%2F%E4%BA%86%E8%A7%A3%E6%B3%A8%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[什么是注解注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻方便地使用这些数据。注解可以提供用来完整地描述程序所需的信息，而这些信息是无法用Java来表达的。 注解的作用及好处 使我们能够以将由编译器来测试和验证的格式，存储有关程序的额外信息。 注解可以用来生成描述符文件，甚至是新的类定义，并且有助于减轻编写“样板”代码的负担。 通过使用注解，我们可以将这些元数据保存在 Java 源代码中，并利用 annotation API 为自己的注解构造处理工具。 更加干净易读的代码以及编译期类型检查。 注解的基本语法注解的语法比较简单，除了 @ 符号的使用之外，他基本与 Java 固有的语法一致。Java SE5 内置了三种，定义在 java.lang 中的注解：@Override 、@Deprecated、@SuppressWarnings。 基本示例在下面的例子中，使用 @Test 对 testExecute() 方法进行注解。该注解本身并不做任何事情，但是编译器要确保在其构造路径上必须有 @Test 注解的定义。 定义注解：123@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123;&#125; 以上代码就是 @Test 注解的定义，与接口的定义非常类似，事实上，注解与接口一样，也会编译成 class文件。除了 @ 符号以外，@ Test 的定义很像一个空的接口。定义注解时，会需要一些元注解（meta-annotation）,如 @Target 和 @Retention。@Target 用来定义你的注解将应用于什么地方（例如一个方法或者是一个域）。@Rectetion 用来定义该注解在哪一个级别可用，在源代码中（SOURCE）、类文件(CLASS)中或者运行时(RUNTIME)。在注解中，一般都会包含一些元素以表达某些值，当分析处理注解时，程序或工具可以利用这些值。注解元素看起来就像接口的方法，唯一的区别就是你可以为其指定默认值。没有元素的注解称为标记注解(marker annotation)，例如上例中的 @Test。 给方法加注解： 123456public class Testable &#123; public void execute()&#123; System.out.println("Executing.."); &#125; @Test void testExecute()&#123;execute();&#125;&#125; 被注解的方法与其他方法没有区别。这个例子中，注解 @Test可以与任何修饰符共同作用于方法，从语法角度看，注解的使用方式几乎和修饰符的使用一模一样。 元注解Java 目前内置了三种标准注解（@Override、@Deprecated、@SuppressWarnings），以及四种元注解，元注解专职负责注解其他的注解： @Target表示该注解可以作用于什么地方。可能的 ElementType 参数包括： CONSTRUCTOR:构造器的声明 FIELD:域（即成员变量）声明（包括enum实例） LOCAL_VARIABLE:局部变量声明 METHOD:方法声明 PACKAGE:包声明 PARAMTETER:参数声明 TYPE:类、接口（包括注解类型）或enum声明 @Retention表示需要什么级别保存该注解信息。。可选的 RetentionPolicy 参数包括： SOURCE:注解将被编译器丢弃 CLASS:注解在 class 文件中可用，但会被 VM 丢弃 RUNTIME:VM 将在运行期也保留注解，因此可通过反射机制读取注解信息 @Documented ：将此注解包含在 Javadoc中 @Inherited：允许子类继承父类中的注解 简单注解处理器我们有时需要根据注解来做一些统计，来掌控项目进展。下面我们做一个小 Demo，来统计已实现的需求和未实现的需求。 首先定义注解，用 id 来区分方法，description 来存储一些方法说明，这一项不填即为默认值。 123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UseCase &#123; public int id(); public String description() default "no description";&#125; 接下来写一个待检查的方法： 12345678910111213141516171819public class PassWordUtils &#123; @UseCase(id=47,description= "密码最起码要有一个数字吧") public boolean validatePassword(String password)&#123; return (password.matches("\\w\\d\\w*")); &#125; @UseCase(id=48) public String encryptPassword(String password)&#123; return new StringBuilder(password).reverse().toString(); &#125; @UseCase(id=49,description= "新密码不能和老密码这么像吧") public boolean checkForNewPassword( List&lt;String&gt; prevPasswords,String password)&#123; return !prevPasswords.contains(password); &#125;&#125; 最后编写注解处理器，用来统计我们已经实现的方法和还未实现的方法。 12345678910111213141516171819202122public class UseCaseTracker &#123; public static void trackUseCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl) &#123; //遍历该类的所有方法 for(Method m:cl.getDeclaredMethods())&#123; //获取加在方法上的UseCase注解 UseCase uc=m.getAnnotation(UseCase.class); if(uc!=null)&#123;//如果方法上确实有UseCase注解 System.out.println("找到了用例:"+uc.id()+" "+uc.description()); useCases.remove(new Integer(uc.id())); &#125; &#125; for(int i:useCases)&#123; System.out.println("警告：丢失用例:"+i); &#125; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; useCases=new ArrayList&lt;&gt;(); Collections.addAll(useCases, 47,48,49,50,51); trackUseCases(useCases, PassWordUtils.class); &#125;&#125; 最后输出结果如下： 注解处理器最佳实践下面我们通过注解要实现的需求是：通过在 JavaBean 上加注解，生成对应的 SQL 语句。这类似于 JavaWeb 的某些框架，虽然是个十分简单的功能，但是却是这些框架的基本原理。下面先定义一个注解，这个注解用来告诉注解处理器，你需要为我生成的数据库表名叫什么：12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface DBTable &#123; public String name() default "";&#125; 接下来是数据库中的各个字段，你需要告诉处理器你的字段名、类型、是否为主键、是否唯一等等。首先定义一个注解，用来告诉处理器你的字段约束。1234567@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Constraints &#123; boolean primaryKey() default false; boolean allowNull() default true; boolean unique() default false;&#125; 接下来是字段类型，我们只选两个代表，String 和 Int。1234567891011121314@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface SQLString &#123; int value() default 0; String name() default ""; Constraints constraints() default @Constraints;&#125;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface SQLInteger &#123; String name() default ""; Constraints constraints() default @Constraints;&#125; 下面是一个简单 Bean 的定义,用到了以上的注解：1234567891011121314@DBTable(name = "STUDENT")public class Student &#123; @SQLString(value = 30, name = "studentname", constraints = @Constraints(allowNull = false)) String name; @SQLString(value = 50, constraints = @Constraints(unique = true)) String enjoy; @SQLInteger(constraints = @Constraints(allowNull = false)) Integer age; @SQLString(value = 30, constraints = @Constraints(primaryKey = true)) String teacherName;&#125; 最后是注解处理器，它将读取一个类文件，检查其上的数据库注解，并生成用来创建数据库的 SQL 命令：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class TableCreator &#123; public static void main(String[] args) throws Exception &#123; Class cl=Student.class; DBTable dbTable = (DBTable) cl.getAnnotation(DBTable.class); if (dbTable == null) &#123; System.out.println(cl.getSimpleName() + "类不能生成一个数据库表格"); return; &#125; String tableName = dbTable.name(); if (tableName.length() &lt; 1) &#123; tableName = cl.getSimpleName().toUpperCase(); &#125; List&lt;String&gt; columnDefs = new ArrayList&lt;&gt;(); for (Field field : cl.getDeclaredFields()) &#123; Annotation[] ans = field.getDeclaredAnnotations(); if (ans.length &lt; 1) continue; String columnName = null; if (ans[0] instanceof SQLInteger) &#123; SQLInteger sInt = (SQLInteger) ans[0]; if (sInt.name().length() &lt; 1) &#123; columnName = field.getName().toUpperCase(); &#125; else &#123; columnName = sInt.name().toUpperCase(); &#125; columnDefs.add(columnName + " INT " + getConstraints(sInt.constraints())); &#125; else if (ans[0] instanceof SQLString) &#123; SQLString sString = (SQLString) ans[0]; if (sString.name().length() &lt; 1) &#123; columnName = field.getName().toUpperCase(); &#125; else &#123; columnName = sString.name().toUpperCase(); &#125; columnDefs.add(columnName + " VARCHAR(" + sString.value() + ") " + getConstraints(sString.constraints())); &#125; &#125; StringBuilder createCommand = new StringBuilder( "CREATE TABLE " + tableName + "(" ); for (String columnDef : columnDefs) &#123; createCommand.append("\n " + columnDef + ","); &#125; String tableCreate=createCommand.substring(0,createCommand.length()-1)+");"; System.out.println("根据" + cl.getName() + "创建数据库：\n" + tableCreate); &#125; private static String getConstraints(Constraints con) &#123; String constraints = ""; if (!con.allowNull()) &#123; constraints += " NOT NULL "; &#125; if (con.primaryKey()) &#123; constraints += " PRIMARY KEY "; &#125; if (con.unique()) &#123; constraints += " UNIQUE "; &#125; return constraints; &#125;&#125; 我们实现的功能还很低级，如果你要改任何属性或者参数，都要重新编译 Java 代码，现在的很多框架都会生成 XML 文件，而不是 SQL 语句，但基本原理都是这样的。 最后本篇文章只是 《Java 编程思想》的学习笔记，看了网上的很多资料，觉得还是这本书讲的最好。]]></content>
    </entry>

    
    <entry>
<<<<<<< HEAD
      <title><![CDATA[Hanler 原理梳理]]></title>
      <url>%2F2017%2F04%2F17%2FHandler%E5%8E%9F%E7%90%86%E6%A2%B3%E7%90%86%2F</url>
      <content type="text"><![CDATA[简介Handler 在 Android 开发中非常常见，它的常见用法相信只要稍微学过一些 Android 基础的朋友都已经烂熟于心，但是他背后的原理对于初学者来说比较复杂，这篇文章梳理了 Handler 的调用流程，通过源码观察 Hanler 背后的原理。 子线程创建 Handler12345new Thread(new Runnable() &#123; @Override public void run() &#123; handler1 = new Handler(); &#125;&#125;).start(); 如果按照上面的代码来创建一个 Handler，运行程序，发现程序崩溃了，错误提示信息如下：1java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare() 也就是说，不能在没有调用 Looper.prepare() 方法的线程中创建 Handler。那么我们就先调用一下 Looper.prepare()。 123456new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); handler1 = new Handler(); &#125; &#125;).start(); 这样程序果然不报错了，这是为什么呢，我们观察源码寻找答案。我们一开始出错是在创建 Handler 的时候，所以很有可能是 Handler 在构造函数里做了些什么，所以我选择首先观察 Handler 构造函数。 123456789101112public Handler(Callback callback, boolean async) &#123; //省略部分源码 mLooper = Looper.myLooper(); if ( mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 可以看到，源码中先是通过 Looper.myLooper() 方法获取一个 Looper 对象，然后判断这个对象是否为空，如果是空的就抛出一个异常，这个异常就是我们刚才看到的那个。为什么不调用 Looper.prepare() 方法 Looper.myLooper() 获取的对象就为空呢？先看 Looper.myLooper()方法： 123public static Looper myLooper() &#123; return sThreadLocal.get();&#125; 原来是把 Looper 存储到了一个线程存储器中，如果没有 Looper 对象，返回自然为空。这个 sThreadLocal 我们是操作不了的，所以想一想就可以知道，一定是 Looper.prepare() 中进行了存储。看 prepare() 方法源码： 123public static void prepare() &#123; prepare(true);&#125; 再往下追： 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 可以看到，首先判断 sThreadLocal 中是否已经存在Looper，如果还没有则创建一个新的 Looper 设置进去。这样也就完全解释了为什么我们要先调用 Looper.prepare() 方法，才能创建 Handler 对象。同时也可以看出每个线程中最多只会有一个 Looper 对象。那为什么我们在主线程可以直接创建 Handler 呢？一定是主线程已经替我们调用了 Looper.prepare() 方法。查看ActivityThread中的main()方法验证我们的猜想,源码如下： 123456789101112131415161718192021public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Security.addProvider(new AndroidKeyStoreProvider()); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); //省略&#125; 可以看到上面的代码调用了一个 Looper.prepareMainLooper() 方法，我一开始以为只要我在子线程也调用 Looper.prepareMainLooper() 方法，就可以在子线程修改 UI 了，但是报错如下：1java.lang.IllegalStateException: The main Looper has already been prepared. 也就是说，我的想法还不算太荒谬， Looper.prepareMainLooper() 方法就是区分子线程和主线程的关键所在。我们进去看看它都做了些什么：123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125; 原来如此，虽然主线程最终也调用了 prepare() 方法,但是给的值是 false，我们之前调用 prepare() 方法，默认值为 true，是不是感觉恍然大悟呢，不得不赞叹源码写的真是巧妙啊！！ 到这里，我相信大家都和我一样，明白了为什么要先调用 Looper.prepare() 方法才可以创建 Handler 对象。我想过自己重写一个Handler 对象试试看能不能跳过这一步，但是你会发现，没有 Looper对象，你创建了也是白搭呀，至于为什么白搭，继续看下面的分析。 Handler 消息发送12345678910new Thread(new Runnable() &#123; @Override public void run() &#123; Message message = new Message(); message.what=1; Bundle bundle = new Bundle(); bundle.putString("data", "data"); message.setData(bundle); handler.sendMessage(message); &#125;&#125;).start(); 这段代码相信大家都非常熟悉了，那它到底把 Message 发到哪里去了呢？Handler 给我们提供了很多方法来发送消息，有 post 的，也有 send 的。通过观察源码，你会发现，除了 enqueueMessage() 方法，其他所有发送消息的方法最后都会走到 sendMessageAtTime() 方法中，但是他们最终都会调用 MessageQueue 类中的 enqueueMessage() 方法，这肯定就是入队方法了：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051boolean enqueueMessage(Message msg, long when) &#123; if (msg.isInUse()) &#123; throw new AndroidRuntimeException(msg + " This message is already in use."); &#125; if (msg.target == null) &#123; throw new AndroidRuntimeException("Message must have a target."); &#125; synchronized (this) &#123; if (mQuitting) &#123; RuntimeException e = new RuntimeException( msg.target + " sending message to a Handler on a dead thread"); Log.w("MessageQueue", e.getMessage(), e); return false; &#125; msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 通过源码可知，这个消息队列实际上是按照发送延时时间，也就是 when 来降序排序的，这样我们发送的消息就按照发送时间排好队了，但是他们排好队要去哪里呢，也就是出队操作在哪执行呢？我们再来分析 ActivityThread 中的 main 方法： 123456789101112131415161718192021222324public static void main(String[] args) &#123; //省略部分源码 Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125; 你会发现，Looper.prepareMainLooper() 或者 Looper.prepare() 方法总是和 Looper.loop() 方法对应，有你必有它，那么我可以合理的怀疑这个 Looper.loop() 方法很有可能就是执行出队操作的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycle(); &#125; &#125; 可以看到，这段代码从 13 行 开始进入了一个死循环，Message msg = queue.next() 就是我们要找的出队方法，而且还是一个阻塞方法，它的简单逻辑就是如果当前 MessageQueue 中存在 mMessages(即待处理消息)，就将这个消息出队，然后让下一条消息成为 mMessages，否则就进入一个阻塞状态，一直等到有新的消息入队。接下来比较重要的代码就是 msg.target.dispatchMessage(msg)，这个 target 其实就是 Handler 发送消息的 Handler 对象，观察 handler 调用入队方法的必经之路 enqueueMessage() 方法可知： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 看上面代码的第二行。 所以我们可以知道，loop() 方法把最新出队的 message 又传给了 Handler 对象 的 dispatchMessage() 方法，所以我们肯定要观察 dispatchMessage() 方法了。 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; dispatchMessage() 方法的逻辑为：如果 msg.callback 不为空(callback 一般是通过 Handler 的 post 系列方法设置的，是一个 Runnable 对象)，则执行 message.callback.run() 方法。否则判断 mCallback 如果不为空，则调用 mCallback 的 handleMessage()方法，否则直接调用 Handler 的 handleMessage() 方法，并将消息对象作为参数传递过去。 总结上面就是 Handler 的一个完整的从信息发送到执行的流程。流程图如下：]]></content>
=======
      <title><![CDATA[aidl 浅析]]></title>
      <url>%2F2017%2F04%2F19%2Faidl%20%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Demo 地址https://github.com/jutao/aidlAIDL客户端 什么是AIDL在 Android中，每一个应用程序独自拥有一个虚拟机，这样做虽然保证了进程之内数据的安全性，保证一个应用程序的数据不受其他应用程序的影响，也保证了一个应用程序挂掉了不至于影响其他应用程序。但是这样也造成了一个应用程序和另外一个应用程序没办法直接进行通讯。AIDL 的作用就是使来自不同应用的客户端跨进程通信访问你的 Service。AIDL 是 Android Interface Definition Language 的缩写，就是安卓内部通信接口描述语言。关于 AIDL的描述和用法我主要参考了Google 的官方API，找到一个中文的，链接：http://www.android-doc.com/guide/components/aidl.html。需要补充的是，API里描述AIDL支持Java语言中的所有基本数据类型，但是经过查证和实验，实际上 AIDL 是不支持Short类型的。 AIDL用法创建 AIDL 接口如果是 Eclipse 的话需要创建 File 并且不要忘记自己打上后缀 .aidl。 写 AIDL 接口AIDL 的用法基本和写普通 Java 接口相同，需要注意的是包名一定要自己检查一下，还有导包也要自己写一下。 12345package com.example.jutao.aidl;interface IServiceAidl &#123;//计算两个数的和int add(int num1,int num2);&#125; 写完之后需要注意，如果你写的 AIDL 接口正确，那么 Ecipse 是会自动编译的，而 Android Studio 需要手动编译，编译按钮如下图所示： 编译通过后，Android Studio 所生成的文件在这里： 写 Service1234567891011//当客户端绑定到该服务的时候@Override public IBinder onBind(Intent intent) &#123; //当别人绑定服务的时候，就会得到AIDL接口 return iBinder;&#125;IBinder iBinder = new IServiceAidl.Stub() &#123; @Override public int add(int num1, int num2) throws RemoteException &#123; Log.d("TAG", "收到服务端请求,求出" + num1 + "和" + num2 + "的和"); return num1 + num2;&#125;&#125;; 1234567&lt;!-- exported 是否支持其它应用调用当前组件 --&gt;&lt;!-- enabled 这个属性用于指示该服务是否能够被实例化。如果设置为true，则能够被实例化，否则不能被实例化。默认值是true --&gt; &lt;service android:name="com.example.aidl_service.RemoteService" android:enabled="true" android:exported="true" &gt; &lt;/service&gt; 写客户端客户端的主要功能是用户通过界面输入两个数字，点击远程计算按钮后通过服务端代码计算出结果返回给客户端并显示。 点击按钮后 需要注意的是，客户端也需要有一模一样的 AIDL 包，连包名都要一模一样！！ 1234567//1、获取服务端Intent intent = new Intent();//Android 5.0之后不支持隐式意图，必须是显式意图来启动绑定服务intent.setComponent(new ComponentName("com.example.jutao.aidl", "com.example.jutao.aidl.RemoteService"));//第三个参数是一个flag，绑定时自动启动bindService(intent, conn, Context.BIND_AUTO_CREATE); conn的定义: 12345678910111213ServiceConnection conn = new ServiceConnection() &#123; //绑定服务时 @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //拿到了远程的服务 iServiceAidl = IServiceAidl.Stub.asInterface(service); &#125; //当服务断开时 @Override public void onServiceDisconnected(ComponentName name) &#123; //回收资源 iServiceAidl = null; &#125; &#125;; AIDL 自定义类型AIDL 默认支持的数据类型如上图所示，虽然支持List类型，但是需要 在List前注明输入List还是输出List，下面的例子会讲到。首先 person 类要实现 Parcelable 接口，详细代码可以在我开头贴的Demo里看。 1234567891011121314151617181920212223242526272829import com.example.jutao.aidl.Person;interface PersonAidl &#123; List&lt;Person&gt; add(in Person person);&#125;parcelable Person;public class PersonService extends Service &#123; private ArrayList&lt;Person&gt; persons; public PersonService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123;persons = new ArrayList&lt;Person&gt;();return iBinder; &#125; private IBinder iBinder = new PersonAidl.Stub() &#123;@Override public List&lt;Person&gt; add(Person person) throws RemoteException &#123; persons.add(person); return persons;&#125; &#125;;&#125; 可以看到，我每次输出的都是 persons 这一List，这是通过服务端返回的，说明我传输过去的值已经被服务端接收并存储。]]></content>
>>>>>>> 333dba136f4dcd9284a99e103790547582a4811f
    </entry>

    
    <entry>
      <title><![CDATA[aidl 浅析]]></title>
      <url>%2F2017%2F04%2F17%2Faidl%20%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Demo 地址https://github.com/jutao/aidlAIDL客户端 什么是AIDL在 Android中，每一个应用程序独自拥有一个虚拟机，这样做虽然保证了进程之内数据的安全性，保证一个应用程序的数据不受其他应用程序的影响，也保证了一个应用程序挂掉了不至于影响其他应用程序。但是这样也造成了一个应用程序和另外一个应用程序没办法直接进行通讯。AIDL 的作用就是使来自不同应用的客户端跨进程通信访问你的 Service。AIDL 是 Android Interface Definition Language 的缩写，就是安卓内部通信接口描述语言。关于 AIDL的描述和用法我主要参考了Google 的官方API，找到一个中文的，链接：http://www.android-doc.com/guide/components/aidl.html。需要补充的是，API里描述AIDL支持Java语言中的所有基本数据类型，但是经过查证和实验，实际上 AIDL 是不支持Short类型的。 AIDL用法创建 AIDL 接口如果是 Eclipse 的话需要创建 File 并且不要忘记自己打上后缀 .aidl。 写 AIDL 接口AIDL 的用法基本和写普通 Java 接口相同，需要注意的是包名一定要自己检查一下，还有导包也要自己写一下。 12345package com.example.jutao.aidl;interface IServiceAidl &#123;//计算两个数的和int add(int num1,int num2);&#125; 写完之后需要注意，如果你写的 AIDL 接口正确，那么 Ecipse 是会自动编译的，而 Android Studio 需要手动编译，编译按钮如下图所示： 编译通过后，Android Studio 所生成的文件在这里： 写 Service1234567891011//当客户端绑定到该服务的时候@Override public IBinder onBind(Intent intent) &#123; //当别人绑定服务的时候，就会得到AIDL接口 return iBinder;&#125;IBinder iBinder = new IServiceAidl.Stub() &#123; @Override public int add(int num1, int num2) throws RemoteException &#123; Log.d("TAG", "收到服务端请求,求出" + num1 + "和" + num2 + "的和"); return num1 + num2;&#125;&#125;; 1234567&lt;!-- exported 是否支持其它应用调用当前组件 --&gt;&lt;!-- enabled 这个属性用于指示该服务是否能够被实例化。如果设置为true，则能够被实例化，否则不能被实例化。默认值是true --&gt; &lt;service android:name="com.example.aidl_service.RemoteService" android:enabled="true" android:exported="true" &gt; &lt;/service&gt; 写客户端客户端的主要功能是用户通过界面输入两个数字，点击远程计算按钮后通过服务端代码计算出结果返回给客户端并显示。 点击按钮后 需要注意的是，客户端也需要有一模一样的 AIDL 包，连包名都要一模一样！！ 1234567//1、获取服务端Intent intent = new Intent();//Android 5.0之后不支持隐式意图，必须是显式意图来启动绑定服务intent.setComponent(new ComponentName("com.example.jutao.aidl", "com.example.jutao.aidl.RemoteService"));//第三个参数是一个flag，绑定时自动启动bindService(intent, conn, Context.BIND_AUTO_CREATE); conn的定义: 12345678910111213ServiceConnection conn = new ServiceConnection() &#123; //绑定服务时 @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //拿到了远程的服务 iServiceAidl = IServiceAidl.Stub.asInterface(service); &#125; //当服务断开时 @Override public void onServiceDisconnected(ComponentName name) &#123; //回收资源 iServiceAidl = null; &#125; &#125;; AIDL 自定义类型AIDL 默认支持的数据类型如上图所示，虽然支持List类型，但是需要 在List前注明输入List还是输出List，下面的例子会讲到。首先 person 类要实现 Parcelable 接口，详细代码可以在我开头贴的Demo里看。 1234567891011121314151617181920212223242526272829import com.example.jutao.aidl.Person;interface PersonAidl &#123; List&lt;Person&gt; add(in Person person);&#125;parcelable Person;public class PersonService extends Service &#123; private ArrayList&lt;Person&gt; persons; public PersonService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123;persons = new ArrayList&lt;Person&gt;();return iBinder; &#125; private IBinder iBinder = new PersonAidl.Stub() &#123;@Override public List&lt;Person&gt; add(Person person) throws RemoteException &#123; persons.add(person); return persons;&#125; &#125;;&#125; 可以看到，我每次输出的都是 persons 这一List，这是通过服务端返回的，说明我传输过去的值已经被服务端接收并存储。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Path 学习笔记之基本操作]]></title>
      <url>%2F2017%2F04%2F16%2FPath%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[path 常用方法一览 为了兼容性(偷懒) 本表格中去除了部分API21(即安卓版本5.0)以上才添加的方法。 作用 相关方法 备注 移动起点 moveTo 移动下一次操作的起点位置 设置终点 setLastPoint 重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同 连接直线 lineTo 添加上一个点到当前点之间的直线到Path 闭合路径 close 连接第一个点连接到最后一个点，形成一个闭合区域 添加内容 addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo 添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别) 是否为空 isEmpty 判断Path是否为空 是否为矩形 isRect 判断path是否是一个矩形 替换路径 set 用新的路径替换到当前路径所有内容 偏移路径 offset 对当前路径之前的操作进行偏移(不会影响之后的操作) 贝塞尔曲线 quadTo, cubicTo 分别为二次和三次贝塞尔曲线的方法 rXxx方法 rMoveTo, rLineTo, rQuadTo, rCubicTo 不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量) 填充模式 setFillType, getFillType, isInverseFillType, toggleInverseFillType 设置,获取,判断和切换填充模式 提示方法 incReserve 提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构) 布尔操作(API19) op 对两个Path进行布尔运算(即取交集、并集等操作) 计算边界 computeBounds 计算Path的边界 重置路径 reset, rewind 清除Path中的内容 reset不保留内部数据结构，但会保留FillType. rewind会保留内部的数据结构，但不保留FillType 矩阵操作 transform 矩阵变换 Path含义Path封装了由直线和曲线(二次，三次贝塞尔曲线)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，也可以用于剪裁画布和根据路径绘制文字。我们有时会用Path来描述一个图像的轮廓，所以也会称为轮廓线(轮廓线仅是Path的一种使用方法，两者并不等价) 直线与点的操作lineTo12345//创建一条从原点到坐标(300,300)的直线mPath.lineTo(500,500);//创建从(500,500)到(100,200)的一条直线mPath.lineTo(100,200); 效果如下： 所以可知 lineTo 方法的连接的起点是由lineTo方法上一个Path操作决定的。 moveTo123//这样改写的话是画一条从(500,500)到(100,200)的线mPath.moveTo(500,500);mPath.lineTo(100,200); 效果如下: 所以可知 moveTo 方法的作用为将下次画路径起点移动到(x,y) setLastPoint123mPath.lineTo(300,300);mPath.setLastPoint(200,200);mPath.lineTo(200,400); 效果如下: 所以可知 setLastPoint 的作用为改变上一次操作路径的结束坐标点。 因此我们可以总结出 moveTo 和 lineTo 的区别为： moveTo 影响上一次操作不影响上一次 setLastPoint上一次和下一次操作都影响 close1234mPath.lineTo(300,300);mPath.setLastPoint(200,200);mPath.lineTo(200,400);mPath.close(); 效果如下： 观察可知 close 的效果为用线段连接起始点和终点，除非起始点等于终点。 基本形状addRect（矩形）123mPath.addRect(50,50,150,150,Direction.CW);mPath.addRect(50,250,150,350,Direction.CCW); 效果如下： 上下两个方法画出来的一模一样，那他们有什么区别呢？我们试着用一下刚学的 setLastPoint 看效果。 123456mPath.addRect(50,50,150,150,Direction.CW);//改变最后一笔的位置mPath.setLastPoint(50,100);mPath.addRect(50,250,150,350,Direction.CCW);mPath.setLastPoint(150,300); 效果如下： 所以我们可以看出 Direction.CW 的最后一笔是左下角，Direction.CCW 的最后一笔是右上角，而且 Android 源码中给 Direction.CW 的注释为 clockwise(顺时针),Direction.CCW 的注释为 counter-clockwise(逆时针),通过这些我们可以很清楚的知道以上两种矩形画法的区别。 而矩形的另外一种画法 public void addRect(RectF rect, Direction dir) 和上面的方法其实一样，只是把坐标封装到了 RectF 对象中而已。 addCircle（圆形）123mPath.addCircle(210,210,200, Path.Direction.CW);mPath.addCircle(800,800,200, Path.Direction.CCW); 效果如下： 画圆非常简单，x，y 代表圆心坐标，radius 代表半径，dir 和矩形一样，代表顺时针或者逆时针。 12345mPath.addCircle(210,210,200, Path.Direction.CW);mPath.setLastPoint(210,210);mPath.addCircle(800,800,200, Path.Direction.CCW);mPath.setLastPoint(800,800); 效果如下： addRoundRect（圆角矩形）圆角矩形主要有两种画法，一种是圆角弧度统一，第二种是定制每一个圆角的弧度。用法如下: 12345678910mPath = new Path();mPath.addRoundRect(rect1,100,100, Path.Direction.CW);RectF rect2=new RectF(100,600,800,1000);/*必须传入8个数值，分四组，分别对应每个角所使用的椭圆的横轴半径和纵轴半径， 如｛x1,y1,x2,y2,x3,y3,x4,y4｝，其中，x1,y1对应第一个角的（左上角）用来产 生圆角的椭圆的横轴半径和纵轴半径，其它类推……*/float[] radii=&#123;100,100,150,150,200,200,300,200&#125;;mPath.addRoundRect(rect2,radii,Path.Direction.CCW); 效果如下： 我标了一下每个圆角半径，很丑： addOval（椭圆）123456RectF rect = new RectF(100, 100, 800, 500);mPath = new Path();mPath.addOval(rect, Path.Direction.CW);//将矩形变为正方形看效果rect = new RectF(100, 600, 300, 800);mPath.addOval(rect, Path.Direction.CW); 效果如下： addArc与arcTo（圆弧）1234567RectF rect = new RectF(100, 100, 800, 500);//开始的角度float startAngle=90;//扫过的角度float sweepAngle=180;mPath = new Path();mPath.addArc(rect,startAngle,sweepAngle); 效果： 关于起始角度以及扫过的角度这些是怎么来的，我理解的是实际上我们是在指定矩形内画一个内切椭圆，通过指定角度在这个椭圆上截取一部分，这一部分就是我们所画的弧。示意图如下，不要嫌丑： 知道了addArc的用法之后，我们来看一下arcTo这个方法，这个方法也是用来画圆弧的，但是与addArc有些不同: addArc 直接添加一段圆弧 arcTo 添加一段圆弧，如果圆弧的起点与上一次Path操作的终点不一样的话，就会在这两个点连成一条直线 12345678RectF rect = new RectF(100, 100, 800, 500);//开始的角度float startAngle=90;//扫过的角度float sweepAngle=180;mPath = new Path();mPath.lineTo(100,100);mPath.arcTo(rect,startAngle,sweepAngle); 效果如下： 可以看到，圆弧的起点并不是直线的终点，于是他们连接在了一起。如果你不想让他们连接怎么办？ mPath.arcTo(rect,startAngle,sweepAngle,true); arcTo 最后一个属性填 true 就可以了。效果如下： addPath（添加Path）先看最普通的 public void addPath (Path src) 123456Path circle=new Path();RectF rect = new RectF(100, 100, 800, 500);mPath = new Path();mPath.addRect(rect, Path.Direction.CW);circle.addCircle(450,300,200, Path.Direction.CW);mPath.addPath(circle); 它将两个path合并在了一起，效果如下： addPath的第二个方法的 dx 和 dy 两个参数是什么意思呢？ 1mPath.addPath(circle,350,-100); 其实它们是代表添加path后的位移值 效果如下： 设置方法set()123456Path circle=new Path();RectF rect = new RectF(100, 100, 800, 500);mPath = new Path();mPath.addRect(rect, Path.Direction.CW);circle.addCircle(450,300,200, Path.Direction.CW);mPath.set(circle); 这个方法就是将path之前的矩形变成圆形。 效果如下： offset()1234RectF rect = new RectF(100, 100, 800, 500);mPath = new Path();mPath.addRect(rect, Path.Direction.CW);mPath.offset(150,150); 它的作用就是将path进行平移 offset() 还有一个参数 dst 是起什么作用呢？ 1234567mPath=new Path();mPath.addCircle(50,50,200, Path.Direction.CW);Path temp=new Path();RectF rect = new RectF(100, 100, 800, 500);temp.addRect(rect, Path.Direction.CW);//相当于用set方法将 temp set 给了mPath，覆盖 mPath 原有的图案temp.offset(150,150,mPath); 效果如下： 可以看到 mPath 之前画的圆已经被覆盖 reset()这个方法很简单，就是将path的所有操作都清空掉。 判断方法isConvex()（这个方法在API21之后才有）判断path是否为凸多边形，如果是就为true，反之为false。 要理解这个方法首先，我们要知道什么是凸多边形。 凸多边形的概念: 每个内角小于180度 任何两个顶点间的线段位于多边形的内部或边界上。 也就是说矩形，三角形，直线都是凸多边形，但是五角星那种形状就不是。现在我们用代码验证一下： 1234567mPath=new Path();mPath.moveTo(100,100);mPath.lineTo(200,200);mPath.lineTo(100,400);mPath.lineTo(300,50);mPath.close();System.out.println(mPath.isConvex()); 效果如下： 很明显，这不是一个凸多边形，查看输出：1I/System.out: false isEmpty这个方法依然很简单，就是判断 path 中是否包含内容 1234mPath=new Path();System.out.println(mPath.isEmpty());mPath.lineTo(300,50);System.out.println(mPath.isEmpty()); 查看输出：12I/System.out: trueI/System.out: false isRect12345mPath=new Path();RectF rect=new RectF();mPath.addRect(100,100,50,50,Path.Direction.CW);System.out.println(mPath.isRect(rect));System.out.println(rect); 判断path是否是一个矩形，如果是一个矩形的话，将矩形的信息存到参数rect中。 输出如下： 12I/System.out: trueI/System.out: RectF(50.0, 50.0, 100.0, 100.0) 最佳实践如果想练习一下 Path知识，可以看一下下面的 blog： Path实战之雷达图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Path学习笔记之Bezier]]></title>
<<<<<<< HEAD
      <url>%2F2017%2F04%2F16%2FPath%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BBezier%2F</url>
=======
      <url>%2F2017%2F04%2F17%2FPath%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BBezier%2F</url>
>>>>>>> 333dba136f4dcd9284a99e103790547582a4811f
      <content type="text"><![CDATA[贝塞尔曲线能干什么？贝塞尔曲线的运用是十分广泛的，可以说贝塞尔曲线奠定了计算机绘图的基础(因为它可以将任何复杂的图形用精确的数学语言进行描述)，在你不经意间就已经使用过它了。 你会使用Photoshop的话，你可能会注意到里面有一个钢笔工具，这个钢笔工具核心就是贝塞尔曲线。 你说你不会PS？ 没关系，你如果看过前面的文章或者用过2D绘图，肯定绘制过圆，圆弧，圆角矩形等这些东西。这里面的圆弧部分全部都是贝塞尔曲线的运用。 贝塞尔曲线作用十分广泛，简单举几个的栗子: QQ小红点拖拽效果 一些炫酷的下拉刷新控件 阅读软件的翻书效果 一些平滑的折线图的制作 很多炫酷的动画效果 贝塞尔曲线的原理贝塞尔曲线是用一系列点来控制曲线状态的，我将这些点简单分为两类： 类型 作用 数据点 确定曲线的起始和结束位置 控制点 确定曲线的弯曲程度 此处暂时仅作了解概念，接下来就会讲解其中详细的含义。 一阶曲线原理一阶曲线是没有控制点的，仅有两个数据点(A 和 B)，最终效果一个线段。 上图表示的是一阶曲线生成过程中的某一个阶段，动态过程可以参照下图(本文中贝塞尔曲线相关的动态演示图片来自维基百科)。 PS：一阶曲线其实就是 Path 的 lineTo 方法。 二阶曲线原理二阶曲线由两个数据点(A 和 C)，一个控制点(B)来描述曲线状态，大致如下： 上图中红色曲线部分就是传说中的二阶贝塞尔曲线，那么这条红色曲线是如何生成的呢？接下来我们就以其中的一个状态分析一下： 连接AB BC，并在AB上取点D，BC上取点E，使其满足条件： 连接DE，取点F，使得: 这样获取到的点F就是贝塞尔曲线上的一个点，动态过程如下： PS: 二阶曲线对应的方法是quadTo 三阶曲线原理三阶曲线由两个数据点(A 和 D)，两个控制点(B 和 C)来描述曲线状态，如下： 三阶曲线计算过程与二阶类似，具体可以见下图动态效果： PS: 三阶曲线对应的方法是cubicTo 其他 贝塞尔曲线速查表 强烈推荐点击这里练习贝塞尔曲线，可以加深对贝塞尔曲线的理解程度。 贝塞尔曲线基本用法一阶曲线一阶曲线是一条线段，非常简单，可以参见上一篇文章Path之基本操作，此处就不详细讲解了。 二阶曲线代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class Bezier extends View&#123; private Paint mPaint; private PointF start,end,control; private int centerX,centerY; public Bezier(Context context) &#123; this(context,null); &#125; public Bezier(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs,0); &#125; public Bezier(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; start=new PointF(0,0); end=new PointF(0,0); control=new PointF(0,0); mPaint=new Paint(); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(8); mPaint.setTextSize(60); mPaint.setAntiAlias(true); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); centerX=w/2; centerY=h/2; start.x=centerX-200; start.y=centerY; end.x=centerX+200; end.y=centerY; control.x=centerX; control.y=centerY-100; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); drawPoint(canvas); drawAuxiliaryLine(canvas); drawBezierPath(canvas); &#125; /** * 绘制数据点和控制点 */ private void drawPoint(Canvas canvas) &#123; mPaint.setColor(Color.GRAY); canvas.drawCircle(start.x,start.y,4,mPaint); canvas.drawCircle(end.x,end.y,4,mPaint); canvas.drawCircle(control.x,control.y,4,mPaint); &#125; /** * 绘制辅助线 */ private void drawAuxiliaryLine(Canvas canvas) &#123; mPaint.setStrokeWidth(4); canvas.drawLine(start.x,start.y,control.x,control.y,mPaint); canvas.drawLine(end.x,end.y,control.x,control.y,mPaint); &#125; /** * 绘制二阶曲线 */ private void drawBezierPath(Canvas canvas) &#123; mPaint.setColor(Color.RED); mPaint.setStrokeWidth(8); Path path=new Path(); path.moveTo(start.x,start.y); path.quadTo(control.x,control.y,end.x,end.y); canvas.drawPath(path,mPaint); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; control.x=event.getX(); control.y=event.getY(); postInvalidate(); return true; &#125;&#125; 效果如下： 三阶曲线代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class Bezier2 extends View&#123; private Paint mPaint; private PointF start,end,control1,control2; private int centerX,centerY; private boolean isControl1=true; public Bezier2(Context context) &#123; this(context,null); &#125; public Bezier2(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs,0); &#125; public Bezier2(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; start=new PointF(0,0); end=new PointF(0,0); control1=new PointF(0,0); control2=new PointF(0,0); mPaint=new Paint(); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(8); mPaint.setTextSize(60); mPaint.setAntiAlias(true); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); centerX=w/2; centerY=h/2; start.x=centerX-300; start.y=centerY; end.x=centerX+300; end.y=centerY; control1.x=centerX-100; control1.y=centerY-200; control2.x=centerX+100; control2.y=centerY-200; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); drawPoint(canvas); drawAuxiliaryLine(canvas); drawBezierPath(canvas); &#125; /** * 绘制数据点和控制点 */ private void drawPoint(Canvas canvas) &#123; mPaint.setColor(Color.GRAY); canvas.drawCircle(start.x,start.y,4,mPaint); canvas.drawCircle(end.x,end.y,4,mPaint); canvas.drawCircle(control1.x,control1.y,4,mPaint); canvas.drawCircle(control2.x,control2.y,4,mPaint); &#125; /** * 绘制辅助线 */ private void drawAuxiliaryLine(Canvas canvas) &#123; mPaint.setStrokeWidth(4); canvas.drawLine(start.x,start.y,control1.x,control1.y,mPaint); canvas.drawLine(end.x,end.y,control2.x,control2.y,mPaint); canvas.drawLine(control1.x,control1.y,control2.x,control2.y,mPaint); &#125; /** * 绘制三阶曲线 */ private void drawBezierPath(Canvas canvas) &#123; mPaint.setColor(Color.RED); mPaint.setStrokeWidth(8); Path path=new Path(); path.moveTo(start.x,start.y); path.cubicTo(control1.x,control1.y,control2.x,control2.y,end.x,end.y); canvas.drawPath(path,mPaint); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if(isControl1)&#123; control1.x=event.getX(); control1.y=event.getY(); &#125;else &#123; control2.x=event.getX(); control2.y=event.getY(); &#125; postInvalidate(); return true; &#125; public void isControl1(boolean control1) &#123; isControl1 = control1; &#125;&#125; 主要的区别就是多了一个控制点，效果如下： 降阶与升阶 三阶曲线相比于二阶曲线可以制作更加复杂的形状，但是对于高阶的曲线，用低阶的曲线组合也可达到相同的效果，就是传说中的降阶。因此我们对贝塞尔曲线的封装方法一般最高只到三阶曲线。 类型 释义 变化 降阶 在保持曲线形状与方向不变的情况下，减少控制点数量，即降低曲线阶数 方法变得简单，数据点变多，控制点可能减少，灵活性变弱 升阶 在保持曲线形状与方向不变的情况下，增加控制点数量，即升高曲线阶数 方法更加复杂，数据点不变，控制点增加，灵活性变强 贝塞尔曲线使用实例在制作这个实例之前，首先要明确一个内容，就是在什么情况下需要使用贝塞尔曲线？ 需要绘制不规则图形时？ 当然不是！目前来说，使用贝塞尔曲线主要有以下几个方面(摘抄) 序号 内容 用例 1 事先不知道曲线状态，需要实时计算时 天气预报气温变化的平滑折线图 2 显示状态会根据用户操作改变时 QQ小红点，仿真翻书效果 3 一些比较复杂的运动状态(配合PathMeasure使用) 复杂运动状态的动画效果 至于只需要一个静态的曲线图形的情况，用图片岂不是更好，大量的计算会很不划算。 如果是显示SVG矢量图的话，已经有相关的解析工具了(内部依旧运用的有贝塞尔曲线)，不需要手动计算。 贝塞尔曲线的主要优点是可以实时控制曲线状态，并可以通过改变控制点的状态实时让曲线进行平滑的状态变化。 我们要实现的效果是使一个圆渐变为心形 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class BezierHeartView extends View &#123; // 一个常量，用来计算绘制圆形贝塞尔曲线控制点的位置 private static final float C = 0.551915024494f; private int mCenterX; private int mCenterY; //圆的半径 private float mCircleRadius = 200; // 圆形的控制点与数据点的差值 private float mDifference = mCircleRadius * C; private Paint mPaint; // 顺时针记录绘制圆形的四个数据点 private float[] mData = new float[8]; // 顺时针记录绘制圆形的八个控制点 private float[] mCtrl = new float[16]; private Paint mFuZhuPaint; // 变化总时长 private float mDuration = 1000; // 当前已进行时长 private float mCurrent = 0; // 将时长总共划分多少份 private float mCount = 100; // 每一份的时长 private float mPiece = mDuration / mCount; public BezierHeartView(Context context) &#123; this(context, null); &#125; public BezierHeartView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public BezierHeartView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setColor(Color.BLACK); mPaint.setStrokeWidth(8); mPaint.setStyle(Paint.Style.STROKE); mPaint.setTextSize(60); mFuZhuPaint = new Paint(); mFuZhuPaint.setStrokeWidth(5); mFuZhuPaint.setColor(Color.RED); mFuZhuPaint.setStyle(Paint.Style.STROKE); //初始化数据点 mData[0] = 0; mData[1] = mCircleRadius; mData[2] = mCircleRadius; mData[3] = 0; mData[4] = 0; mData[5] = -mCircleRadius; mData[6] = -mCircleRadius; mData[7] = 0; //初始化控制点 mCtrl[0] = mData[0] + mDifference; mCtrl[1] = mData[1]; mCtrl[2] = mData[2]; mCtrl[3] = mData[3] + mDifference; mCtrl[4] = mData[2]; mCtrl[5] = mData[3] - mDifference; mCtrl[6] = mData[4] + mDifference; mCtrl[7] = mData[5]; mCtrl[8] = mData[4] - mDifference; mCtrl[9] = mData[5]; mCtrl[10] = mData[6]; mCtrl[11] = mData[7] - mDifference; mCtrl[12] = mData[6]; mCtrl[13] = mData[7] + mDifference; mCtrl[14] = mData[0] - mDifference; mCtrl[15] = mData[1]; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mCenterX = w / 2; mCenterY = h / 2; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制坐标系 drawCoordinateSystem(canvas); //绘制辅助线 drawAuxiliaryLine(canvas); // 绘制贝塞尔曲线 drawBezier(canvas); //幻化为心 changeBezier(canvas); &#125; private void changeBezier(Canvas canvas) &#123; mCurrent+=mPiece; if(mCurrent&lt;=mDuration)&#123; mData[1]+=120/mCount; mData[5]+=150/mCount; mCtrl[0]-=80/mCount; mCtrl[14]+=80/mCount; mCtrl[4]-=20/mCount; mCtrl[10]+=20/mCount; postInvalidateDelayed((long) mPiece); &#125; &#125; private void drawBezier(Canvas canvas) &#123; mPaint.setColor(Color.RED); mPaint.setStrokeWidth(8); mPaint.setStyle(Paint.Style.STROKE); Path path = new Path(); path.moveTo(mData[0], mData[1]); for (int i = 2, j = 0; j &lt; mCtrl.length; i += 2, j += 4) &#123; path.cubicTo(mCtrl[j], mCtrl[j + 1], mCtrl[j + 2], mCtrl[j + 3], mData[i % mData.length], mData[(i + 1) % mData.length]); &#125; canvas.drawPath(path, mPaint); &#125; private void drawAuxiliaryLine(Canvas canvas) &#123; mPaint.setColor(Color.GRAY); mPaint.setStrokeWidth(2); mPaint.setStyle(Paint.Style.FILL); for (int i = 0, j = 0; i &lt; mData.length; i += 2, j += 4) &#123; canvas.drawCircle(mData[i], mData[i + 1], 4, mPaint); canvas.drawCircle(mCtrl[j], mCtrl[j + 1], 4, mPaint); canvas.drawCircle(mCtrl[j + 2], mCtrl[j + 3], 4, mPaint); &#125; for (int i = 0, j = 0; j &lt; mCtrl.length; i += 2, j += 4) &#123; canvas.drawLine(mData[i], mData[i + 1], mCtrl[j], mCtrl[j + 1], mPaint); canvas.drawLine(mCtrl[j], mCtrl[j + 1], mCtrl[j + 2], mCtrl[j + 3], mPaint); canvas.drawLine(mCtrl[j + 2], mCtrl[j + 3], mData[(i + 2) % mData.length], mData[(i + 3) % mData.length], mPaint); &#125; &#125; private void drawCoordinateSystem(Canvas canvas) &#123; canvas.drawLine(0, mCenterY, mCenterX * 2, mCenterY, mFuZhuPaint); canvas.drawLine(mCenterX, 0, mCenterX, mCenterY * 2, mFuZhuPaint); canvas.translate(mCenterX, mCenterY); &#125;&#125; 预览效果： 参考资料Path之贝塞尔曲线]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-策略模式]]></title>
      <url>%2F2017%2F04%2F16%2F%5BAndroid%5D%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[最简单的商场收银软件如果要做一款收银软件，营业员根据客户所购买商品单价和数量向客户收费，这非常容易。 Demo 如下： 点击确定后的代码逻辑如下: 1234567891011121314151617181920212223242526272829private void doEnter() &#123;String stringTotal = tv_total.getText().toString().trim();double total;if (stringTotal != null &amp;&amp; stringTotal != "") &#123; total = Double.valueOf(stringTotal);&#125; else &#123; total = 0.0d;&#125;String stringDJ = et_dj.getText().toString().trim();String stringSL = et_sl.getText().toString().trim();if (stringDJ != null &amp;&amp; !stringDJ.equals("") &amp;&amp; stringSL != null &amp;&amp; !stringSL.equals("")) &#123; Log.d("TAG", "123" + stringDJ + "123"); double price = Double.valueOf(stringDJ); int number = Integer.valueOf(stringSL); double totalPrice = price * number; total = total + totalPrice; tv_total.setText(String.valueOf(total)); String text = tv_detail.getText().toString() + "单价： " + price + " 数量：" + number + " 合计:" + totalPrice + "\n"; tv_detail.setText(text);&#125;&#125; 增加打折功能后的收银软件可是如果商场搞促销，需要打折该怎么办，不可能每次都要修改代码然后重新安装，用下拉框可能会比较方便。Demo 如下： 添加的代码如下：1234567891011 switch (sp_jsfs.getSelectedItemPosition())&#123; case 1: totalPrice*=0.8; break; case 2: totalPrice*=0.7; break; case 3: totalPrice*=0.5; break;&#125; 这样看似解决了问题，但是需求不断增加，比如满300返50之类，这样的代码未免显得太过重复。接下来我们试着用简单工厂模式来解决问题试试。 简单工厂实现 面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象抽象集合才是类。 打一折和九折只是形式的不同，抽象分析出来，所有打折算法都是一样的，所以打折算法应该是一个类。返现算法也是一个类。 MainActivity 改动如下： 12CashSuper cSuper= CashFactor.createCashAccept(sp_jsfs.getSelectedItemPosition());totalPrice=cSuper.acceptCash(totalPrice); 详细代码可以去最后上传的Demo里看 简单工厂模式虽然也能解决问题，但只是解决对象创建的问题，而且由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折和返利额度，每次维护或扩展收费方式都要改动这个工厂，以至代码要重新编译部署，这是很糟糕的，所以我们需要另一种新的设计模式–策略模式。 策略模式什么是策略模式 策略模式就是定义一系列算法，把他们独立封装起来，并且这些算法之间可以相互替换。策略模式主要是管理一堆有共性的算法，客户端可以根据需要，很快切换这些算法，并且保持可扩展性。策略模式的本质：分离算法，选择实现。 如何运用到收银系统中商场收银如何促销，用打折还是返利，其实都是一些算法，用工厂来生成算法对象，这没有错，但算法本身只是一种策略，最重要的是这些算法是随时都可能互相替换的，这是变化点，而封装变化点是我们面向对象的一种很重要的思维方式。 以下是策略模式 UML 图 接下来我们将策略模式运用到收银系统中 首先创建一个 CashContext 代码如下： 1234567891011public class CashContext &#123; private CashSuper cs; public CashContext(CashSuper cs) &#123; this.cs = cs; &#125; public double GetResule(double money)&#123; return cs.acceptCash(money); &#125;&#125; 然后改动 MainActivity 如下： 12345678910111213141516171819CashContext cc = null; switch (sp_jsfs.getSelectedItemPosition()) &#123; case 0: cc = new CashContext(new CashNormal()); break; case 1: cc = new CashContext(new CashReturn(300, 100)); break; case 2: cc = new CashContext(new CashRebate(0.8)); break; case 3: cc = new CashContext(new CashRebate(0.7)); break; case 4: cc = new CashContext(new CashRebate(0.5)); break; &#125; totalPrice = cc.GetResule(totalPrice); 这时候，你会发现，我们又像原来一样在 MainActivity 中写了判断，可以试着将之前的工厂模式和策略模式结合吗？ 策略模式与简单工厂结合将 CashContext 类的构造方法修改如下： 12345678910111213141516171819public CashContext(int type) &#123; switch (type) &#123; case 0: cs=new CashNormal(); break; case 1: cs=new CashReturn(300,100); break; case 2: cs = new CashRebate(0.8); break; case 3: cs = new CashRebate(0.7); break; case 4: cs = new CashRebate(0.5); break; &#125; &#125; MainActivity 代码修改如下： 123CashContext cc = new CashContext(sp_jsfs.getSelectedItemPosition()); totalPrice = cc.GetResule(totalPrice); total = total + totalPrice; 这样客户端只需要认识一个类 CashContext就可以了，耦合度进一步降低了。不过这样一旦需求变化依旧需要修改 switch ，其实想要更好的实现可以用反射方法，具体用法下次再做讨论。 Demo策略模式 Demo 参考文献《大话设计模式》 安卓设计模式–策略模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Path 实战]]></title>
      <url>%2F2017%2F04%2F15%2FPath%E5%AE%9E%E6%88%98%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[准备我们将从0到1一步一步来画一个 web 页面很常见的雷达图 第一步：绘制蜘蛛网络1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void init() &#123; mainPaint=new Paint(); mainPaint.setColor(Color.BLACK); mainPaint.setAntiAlias(true); mainPaint.setStrokeWidth(1); mainPaint.setStyle(Paint.Style.STROKE);&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; radius=Math.min(w,h)/2*0.9f; centerX=w/2; centerY=h/2; //一旦size发生改变，重新绘制 postInvalidate(); super.onSizeChanged(w, h, oldw, oldh);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; drawPolygon(canvas);&#125;/** * 绘制多边形 * @param canvas */private void drawPolygon(Canvas canvas)&#123; Path path=new Path(); //1度=1*PI/180 360度=2*PI 那么我们每旋转一次的角度为2*PI/内角个数 //中心与相邻两个内角相连的夹角角度 angle= (float) (2*Math.PI/count); //每个蛛丝之间的间距 float r= radius/(count-1); for (int i = 0; i &lt; count; i++) &#123; //当前半径 float curR=r*i; path.reset(); for (int j = 0; j &lt; count; j++) &#123; if(j==0)&#123; path.moveTo(centerX+curR,centerY); &#125;else &#123; //对于直角三角形sin(x)是对边比斜边，cos(x)是底边比斜边，tan(x)是对边比底边 //因此可以推导出:底边(x坐标)=斜边(半径)*cos(夹角角度) // 对边(y坐标)=斜边(半径)*sin(夹角角度) float x = (float) (centerX+curR*Math.cos(angle*j)); float y = (float) (centerY+curR*Math.sin(angle*j)); path.lineTo(x,y); &#125; &#125; path.close(); canvas.drawPath(path,mainPaint); &#125; 绘制蜘蛛网络其实就是绘制指定边数的正多边形，这一步比较简单，比较难的可能就是每个顶点的算法，相关注释我都写了，还有一张来自互联网的图以助于思考，如下： 绘制出的多边形成品如下: 动画效果只是写了 set 方法，用 handler 实现,代码如下： 1234567891011//设置数值种类public void setCount(int count) &#123; this.count = count; postInvalidate();&#125;//设置蜘蛛网颜色public void setMainPaint(Paint mainPaint) &#123; this.mainPaint = mainPaint; postInvalidate();&#125; 调用方法: 12345678910111213141516mainPaint=new Paint();mainPaint.setAntiAlias(true);mainPaint.setStrokeWidth(1);mainPaint.setStyle(Paint.Style.STROKE);Handler handler=new Handler();for (int i = 3; i &lt; 20; i++) &#123;final int finalI = i;handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mRdv.setCount(finalI); mainPaint.setStrokeWidth(finalI); mRdv.setMainPaint(mainPaint); &#125;&#125;,i*300);&#125; 第二步：绘制对角线1234567891011121314/** * 绘制直线 */private void drawLines(Canvas canvas)&#123; Path path=new Path(); for (int i = 0; i &lt; count; i++) &#123; path.reset(); path.moveTo(centerX,centerY); float x = (float) (centerX+radius*Math.cos(angle*i)); float y = (float) (centerY+radius*Math.sin(angle*i)); path.lineTo(x,y); canvas.drawPath(path,mainPaint); &#125;&#125; 这一步比较简单，就是将中心点和各个顶点连接起来，效果如下: 第三步：绘制标题文字12345678910111213141516171819202122232425262728293031323334353637/** * 绘制标题文字 * * @param canvas */private void drawTitle(Canvas canvas) &#123; if (count != titles.size()) &#123; return; &#125; //相关知识点:http://mikewang.blog.51cto.com/3826268/871765/ Paint.FontMetrics fontMetrics = textPaint.getFontMetrics(); float fontHeight = fontMetrics.descent - fontMetrics.ascent; //绘制文字时不让文字和雷达图形交叉,加大绘制半径 float textRadius = radius + fontHeight; double pi = Math.PI; for (int i = 0; i &lt; count; i++) &#123; float x = (float) (centerX + textRadius * Math.cos(angle * i)); float y = (float) (centerY + textRadius * Math.sin(angle * i)); //当前绘制标题所在顶点角度 float degrees = angle * i; //从右下角开始顺时针画起,与真实坐标系相反 if (degrees &gt;= 0 &amp;&amp; degrees &lt; pi / 2) &#123;//第四象限 float dis=textPaint.measureText(titles.get(i))/(titles.get(i).length()-1); canvas.drawText(titles.get(i), x+dis, y, textPaint); &#125; else if (degrees &gt;= pi / 2 &amp;&amp; degrees &lt; pi) &#123;//第三象限 float dis=textPaint.measureText(titles.get(i))/(titles.get(i).length()-1); canvas.drawText(titles.get(i), x-dis, y, textPaint); &#125; else if (degrees &gt;= pi &amp;&amp; degrees &lt; 3 * pi / 2) &#123;//第二象限 float dis=textPaint.measureText(titles.get(i))/(titles.get(i).length()); canvas.drawText(titles.get(i), x-dis, y, textPaint); &#125; else if (degrees &gt;= 3 * pi / 2 &amp;&amp; degrees &lt;= 2 * pi) &#123;//第一象限 canvas.drawText(titles.get(i), x, y, textPaint); &#125; &#125;&#125; 效果如下： 第四步：绘制覆盖区域要绘制覆盖区域，首先要指定最大值和每个分类的具体数值,有了这些数值之后，就可以绘制了。 代码如下： 12345678910111213141516171819202122232425262728293031/** * 绘制覆盖区域 */private void drawRegion(Canvas canvas)&#123; valuePaint.setAlpha(255); Path path=new Path(); for (int i = 0; i &lt; count; i++) &#123; //计算该数值与最大值比例 Double perCenter = data.get(i)/maxValue; //小圆点所在位置距离圆心的距离 double perRadius=perCenter*radius; float x = (float) (centerX + perRadius * Math.cos(angle * i)); float y = (float) (centerY + perRadius * Math.sin(angle * i)); if(i==0)&#123; path.moveTo(x,y); &#125;else &#123; path.lineTo(x,y); &#125; //绘制小圆点 canvas.drawCircle(x,y,10,valuePaint); &#125; //闭合覆盖区域 path.close(); valuePaint.setStyle(Paint.Style.STROKE); //绘制覆盖区域外的连线 canvas.drawPath(path, valuePaint); //填充覆盖区域 valuePaint.setAlpha(128); valuePaint.setStyle(Paint.Style.FILL); canvas.drawPath(path,valuePaint);&#125; 看一下效果： 再来看一下动态的效果吧： 总结终于完成了,全部代码在下面： Android雷达图全部代码 主要是参考 crazy__chen 大神的博客，链接贴在下面，做了一遍其实还蛮简单的，这个控件还有很多不完善的，如果实际使用需要改善的地方还有很多，如果有不足希望大家可以告诉我，谢谢！！ 参考资料 Android雷达图(蜘蛛网图)绘制 Path之基本操作]]></content>
    </entry>

    
  
  
</search>
